#include "pch.h"

// The class we are implementing
#include "GameBlackOps4.h"

// We need the CoDAssets class
#include "CoDAssets.h"
#include "CoDRawImageTranslator.h"
#include "CoDXPoolParser.h"

// We need the following WraithX classes
#include <Path.h>
#include <File.h>
#include "MemoryReader.h"
#include "Half.h"
#include <Environment.h>

// -- Initialize Asset Name Cache

WraithNameIndex GameBlackOps4::AssetNameCache = WraithNameIndex();
// -- Initialize Decryption Table
uint32_t DecryptionTable[4082] = 
{
    0x024FCAAE, 0x02E543B3, 0x001C94DD, 0x051D15E4, 0x00FB831A, 0x01E16CA9, 0x0285BE0A, 0x05910248,
    0x022CDDE4, 0x05C224AE, 0x00A9ADC0, 0x00B04EB8, 0x037AC36C, 0x05E6572A, 0x00486B19, 0x01049B4E,
    0x04854CEA, 0x0428329C, 0x01C6D5BB, 0x0287696E, 0x02A2FF6A, 0x034C2EC8, 0x01494A9C, 0x05423467,
    0x0242E23F, 0x00DC7519, 0x01BA84E2, 0x000089E8, 0x053F3E36, 0x00139F8B, 0x04290529, 0x01416AD3,
    0x05282D1A, 0x01AA92E0, 0x0012B273, 0x00567ED0, 0x02A8FCA8, 0x04BFF024, 0x02F86A5F, 0x0481E0A1,
    0x025CAC0C, 0x027C2E9C, 0x0072382C, 0x047DAB8A, 0x01F01582, 0x011ED5A0, 0x03980131, 0x00DE927F,
    0x026DD7B9, 0x015BF6AE, 0x02CCAF4E, 0x003BE854, 0x01C95C5E, 0x00A02EC7, 0x02DE8730, 0x02E80050,
    0x03FAF5CC, 0x0314D710, 0x014C670F, 0x02055940, 0x0055565A, 0x054B23AE, 0x02B10306, 0x04B0BCBB,
    0x04163738, 0x05B4E93C, 0x04768B4F, 0x053AB7ED, 0x005C1E6C, 0x031382A3, 0x02130FD9, 0x0054FEB1,
    0x02A181F0, 0x044AE23E, 0x02BB04F4, 0x051A8956, 0x0547E031, 0x036DC06F, 0x004C6FA7, 0x04374E8B,
    0x033FA267, 0x017EBF80, 0x006BD4C4, 0x02D9C992, 0x05D33639, 0x01529B14, 0x05E98D84, 0x03632D65,
    0x012DC204, 0x058E6490, 0x00688E22, 0x03253B52, 0x01AED0FF, 0x010D5413, 0x02F8FD4D, 0x059EC6FC,
    0x03ABECEC, 0x03DE206B, 0x023A0102, 0x05D865F5, 0x02074C7A, 0x034B0997, 0x04EBDE18, 0x001ADCBE,
    0x0017FBC1, 0x00A8B5B9, 0x0283F950, 0x041F50B5, 0x02FF1515, 0x0384CD93, 0x03E7A258, 0x04684054,
    0x01D91A26, 0x025AAB26, 0x019EE2F1, 0x05052E94, 0x00AE4DE7, 0x0335142E, 0x056241B8, 0x01710AFC,
    0x02B6AB9D, 0x02C1BF04, 0x01F6FABD, 0x03BE0FA9, 0x01EBE480, 0x0241E913, 0x05AF4850, 0x03235330,
    0x021C4901, 0x0349BA7B, 0x0159EDE0, 0x032BB658, 0x01AB7573, 0x02FE58CF, 0x0121E5CE, 0x01F8129D,
    0x00921A22, 0x00950E8A, 0x0178603C, 0x03D9F256, 0x013809F3, 0x0589FAFA, 0x02C193CF, 0x00EF853B,
    0x04B9868C, 0x0484D855, 0x0148A452, 0x00D1388C, 0x014F3567, 0x02E97654, 0x01CF730E, 0x040F358A,
    0x028C86D1, 0x016CCA1C, 0x040A639A, 0x0543928B, 0x04E71CC1, 0x01CCADFF, 0x02D8D48A, 0x045AC398,
    0x009AFDDF, 0x00A5EF7B, 0x03B7F2AE, 0x0036E2AF, 0x004AB0DD, 0x02990FCD, 0x018C3569, 0x031DD4D2,
    0x0336A14A, 0x0058D471, 0x047555D6, 0x0156B98C, 0x039DE656, 0x01E747AE, 0x03855AE8, 0x05BE93E3,
    0x03AEFDA6, 0x0304034B, 0x04AB93D3, 0x002F351A, 0x0090BE42, 0x049CD195, 0x0461CEBC, 0x014AF555,
    0x0154BE99, 0x04F43602, 0x05C716EC, 0x05D84C73, 0x004DFE46, 0x03219F01, 0x02AD5EB0, 0x05BDCE73,
    0x0106218B, 0x00172642, 0x02E72DF6, 0x04971C50, 0x0492B2C1, 0x04ED6643, 0x02597E66, 0x0142D601,
    0x0157E2A6, 0x040A5B1F, 0x0459F64D, 0x02487C59, 0x0237A513, 0x016802AA, 0x05260BA6, 0x018E98A3,
    0x050B31DD, 0x05D793FC, 0x00598AA0, 0x03AF13C3, 0x031A06F5, 0x028B1268, 0x048FF374, 0x0158FDC0,
    0x02EA61E2, 0x01127CA2, 0x0168BC1C, 0x052113CB, 0x01D5CAA7, 0x05EADAFA, 0x042CEBC2, 0x0412A258,
    0x0086EC74, 0x0497AECA, 0x0506CE04, 0x0011398C, 0x058334E3, 0x0568E3CE, 0x05AB7E89, 0x031209D6,
    0x014D127A, 0x01A0E46E, 0x056E872A, 0x03CA2CB8, 0x021EA7B1, 0x0372D3E7, 0x05E01B5B, 0x032FC24F,
    0x04B96D8B, 0x02611EEA, 0x0461EB76, 0x04979DE4, 0x0571468A, 0x02C171EC, 0x03531F1D, 0x012DDAEE,
    0x00523E8F, 0x01ECBCCE, 0x01B51864, 0x05A36540, 0x0133534B, 0x03467777, 0x040DD017, 0x01824869,
    0x048C9D20, 0x036539A5, 0x03C68A72, 0x055C4295, 0x057975E0, 0x015B0919, 0x0474CF1D, 0x0474EF15,
    0x002B612C, 0x02EEC3FA, 0x027CD17F, 0x01DC6461, 0x0037CD33, 0x03518FA9, 0x00107061, 0x0453B8A5,
    0x0461757D, 0x0545AD82, 0x00EB436A, 0x024B3129, 0x00442440, 0x0041D22F, 0x048480FA, 0x04751AD1,
    0x04FA4F28, 0x026BD287, 0x035E41C8, 0x01CAD485, 0x01D0CFA1, 0x0101A020, 0x0509F531, 0x02329C75,
    0x01AFB07A, 0x034217A6, 0x015BFB0C, 0x0564BB03, 0x04F29C5E, 0x00FB0277, 0x05223186, 0x022407A5,
    0x01CEE7CA, 0x011CA27D, 0x022C7C41, 0x00D44D1D, 0x012E9B3E, 0x02FDB9B5, 0x0537BC48, 0x056FEAC8,
    0x03E0EF62, 0x02864C8C, 0x013FAC0B, 0x01707B86, 0x044BEA16, 0x0578EC4F, 0x027217EF, 0x02B8ACC0,
    0x054635ED, 0x03F742A9, 0x0051D525, 0x04BDBAF7, 0x0198FAC4, 0x02292BA3, 0x01EE57C0, 0x044CF159,
    0x016F4A8B, 0x00A4E9A0, 0x00CE76DD, 0x0409480B, 0x011353B6, 0x02787BE6, 0x05824ACA, 0x030DBFE9,
    0x00036886, 0x0443C752, 0x00023C76, 0x030F29DD, 0x024ECD12, 0x03E3E1F9, 0x045FFB50, 0x03ACED97,
    0x004B5BB4, 0x05DD1E0A, 0x0362FD4F, 0x02F87354, 0x014327FA, 0x0563D944, 0x05EDD077, 0x01271C10,
    0x02D35C80, 0x03B7CBEC, 0x0038DF7D, 0x040823D2, 0x0351A8DE, 0x03C16548, 0x0456488E, 0x05439A9E,
    0x0339DBBC, 0x03B54EFB, 0x054F445E, 0x051051F5, 0x037C2712, 0x05C958E8, 0x03C16E96, 0x059D1960,
    0x01C4A895, 0x01706CEB, 0x006F197E, 0x04C43CFE, 0x046B1E3C, 0x01136615, 0x011D11E4, 0x037E0CD8,
    0x05672AB4, 0x01BD762D, 0x01E334EE, 0x0461B39A, 0x00208EB4, 0x05745E76, 0x05A5CF8A, 0x0198196B,
    0x03B95FB9, 0x0168406C, 0x04EB5D43, 0x00BC584D, 0x056AFB18, 0x0036AA3D, 0x03328DB3, 0x009891B1,
    0x005EC2BD, 0x047216CA, 0x04B4CA45, 0x05E37B2D, 0x0414C582, 0x00A7C106, 0x0158CFA0, 0x024EC0F3,
    0x00B6F4B1, 0x035227C7, 0x027336E2, 0x03F28321, 0x00C4155A, 0x034ED321, 0x05B22437, 0x03961F0C,
    0x0042FB9D, 0x041D4BD6, 0x047EB68F, 0x01F8B603, 0x04AC99D2, 0x05E3076A, 0x0111C712, 0x026034A8,
    0x0590502A, 0x053914CA, 0x01651296, 0x02E271C2, 0x00C323C5, 0x00C84B80, 0x01A1BC46, 0x02512581,
    0x0501090C, 0x03628901, 0x0207D755, 0x05629C10, 0x05A5D762, 0x0549E62E, 0x0195ECF6, 0x01CAA042,
    0x03A564E4, 0x00797D48, 0x05542E88, 0x05536D96, 0x03E0D5D7, 0x041AC0D5, 0x05A2C768, 0x00779C5E,
    0x05DAED43, 0x00CC5102, 0x053BF90A, 0x01ED1708, 0x044F5B47, 0x055AE782, 0x0061EE31, 0x0170E077,
    0x0560DB0D, 0x0466B459, 0x054D178B, 0x05DB380E, 0x00DF46B0, 0x030DD6DC, 0x01255BFA, 0x02A9893E,
    0x05A65818, 0x046D76DD, 0x0336C8A7, 0x02382CEF, 0x01A81725, 0x0219E620, 0x006462F5, 0x02C60639,
    0x042025FD, 0x0375F559, 0x04387DA7, 0x05633D91, 0x0047DE78, 0x002DCA66, 0x03A80AE4, 0x058285FC,
    0x0531287A, 0x019DCFAF, 0x036BAA63, 0x002C7F06, 0x017E82AF, 0x04C5C5AA, 0x02276F70, 0x0189BF30,
    0x0313B370, 0x03D8D2C1, 0x009396B5, 0x05A0B9F3, 0x04154230, 0x00AD1A99, 0x05A52386, 0x03AAD507,
    0x02C3D343, 0x05F2616C, 0x00DCEB81, 0x01C07B25, 0x00607BDA, 0x00E1C867, 0x04D47834, 0x026A573B,
    0x03B88356, 0x00FBAC6D, 0x01A90545, 0x01DD2CC1, 0x05D26034, 0x03F40110, 0x05C9C5E8, 0x008B7537,
    0x02CD43E3, 0x03A27A2D, 0x034144AC, 0x02C11BCF, 0x03724928, 0x00B3B053, 0x022E88E9, 0x01567D7D,
    0x04A1BF77, 0x030C1D62, 0x016B503E, 0x02E12B5A, 0x0295F283, 0x02F87A55, 0x000F5203, 0x024A5D47,
    0x00F4E42A, 0x05C642FC, 0x0133E099, 0x04DAB872, 0x04170FE4, 0x05F5B77E, 0x04F19441, 0x036B4187,
    0x04EC53F1, 0x01EB55FD, 0x00F5680D, 0x035365A1, 0x004EF362, 0x05EB5E4F, 0x03C9AB1A, 0x048ED0B5,
    0x0200F765, 0x01EE049E, 0x032D0C0D, 0x042D554D, 0x05B75A4B, 0x00100910, 0x0154D613, 0x00233723,
    0x04403AC1, 0x015EABCB, 0x036B9B95, 0x04B19887, 0x004D4959, 0x007C8B0D, 0x018942B8, 0x05B3A520,
    0x05235658, 0x0029DDE7, 0x0494CB54, 0x01552671, 0x02F5795F, 0x026C0EAA, 0x0079DA0F, 0x03A148A7,
    0x04D38230, 0x01328B8D, 0x057E5896, 0x01552087, 0x0333EC3F, 0x0162655F, 0x0148330C, 0x028B9DD6,
    0x015A28CF, 0x012D7393, 0x040F050F, 0x00FE6EB9, 0x01B98D86, 0x039A609A, 0x00437BBF, 0x0310FE9F,
    0x01756B9A, 0x01061764, 0x03F7CDFD, 0x02CEDA5C, 0x02B2DB4B, 0x038398E4, 0x052DDE74, 0x04D5DDCA,
    0x057383E6, 0x00FD2595, 0x0108205E, 0x00DE3AA2, 0x038FBFF3, 0x050BFAB3, 0x024D4B54, 0x0391DACC,
    0x0149BD58, 0x02558C59, 0x03A29F8C, 0x02D9508C, 0x02B45DB2, 0x04AD42FF, 0x00C1BD31, 0x00BAC196,
    0x0498DC75, 0x05D8D38C, 0x02F9DFF4, 0x04A8E4FC, 0x02085D60, 0x000392CE, 0x002D94BE, 0x0498D374,
    0x0279A0B3, 0x05B56A58, 0x003E86BD, 0x00F4E277, 0x0108A2A4, 0x00B14CA8, 0x0469467D, 0x00ACACD6,
    0x0183A178, 0x00F031D3, 0x01432D18, 0x050E1A04, 0x0064071E, 0x052CB04D, 0x038B9605, 0x03D9C6F9,
    0x033A9138, 0x04FFE2DE, 0x01660324, 0x02E357D0, 0x021AB903, 0x0428D708, 0x00F74ED3, 0x0044D014,
    0x0167E13D, 0x023DF609, 0x04649677, 0x03C6E540, 0x03140DDD, 0x05D3D485, 0x04AB2EB7, 0x005A4335,
    0x01029949, 0x01227702, 0x00EEEF95, 0x056B228A, 0x046C29E5, 0x03687563, 0x036D124C, 0x05E7FD82,
    0x00FC7B25, 0x006ED015, 0x02DC0360, 0x014EDBA7, 0x04875827, 0x0429CCFF, 0x04135E02, 0x055ECBEF,
    0x00E3EB1D, 0x011D8B75, 0x0486A7F2, 0x033B37F9, 0x029F7F7D, 0x00E2CD37, 0x01270CFC, 0x01699B3A,
    0x01B17758, 0x03DC1F00, 0x03AC6FD7, 0x0141165F, 0x053A3024, 0x04294FB9, 0x0505EC95, 0x0224A445,
    0x056A6A39, 0x057E823B, 0x0199A1C2, 0x01A2B4C1, 0x05819937, 0x01CF2E26, 0x0281E1CA, 0x02FD30AE,
    0x0323B872, 0x01499638, 0x05E14166, 0x005048CF, 0x03299FB8, 0x0048C449, 0x048642C4, 0x03FCF2B2,
    0x05844EFE, 0x03C51553, 0x0088347F, 0x0096CD29, 0x03FCC4C9, 0x04DA9532, 0x044E6044, 0x037B74EF,
    0x0504641C, 0x04D1B0DA, 0x04A0ECBC, 0x03DB6018, 0x024D92FC, 0x026000EE, 0x002FF079, 0x044711FC,
    0x01F52C1A, 0x015EB855, 0x0558B2E2, 0x0052FF5A, 0x039A6991, 0x05531E4C, 0x03A3B82C, 0x00145198,
    0x01DADB24, 0x00B31E74, 0x029A789B, 0x029F04F6, 0x04DC985C, 0x00EF2478, 0x028EB497, 0x01AEC588,
    0x04927AEA, 0x00AE1166, 0x00CCD449, 0x0005C892, 0x0120CA41, 0x00F280C8, 0x02E70480, 0x055CE9F8,
    0x0236EB13, 0x031A3CBE, 0x03D4F5B9, 0x00C37796, 0x0447731C, 0x04AE23F2, 0x02418813, 0x039EA2AB,
    0x03051CCF, 0x0053A7AC, 0x040E2DA1, 0x03CA13D5, 0x050B189E, 0x02C774BC, 0x0209C8D7, 0x02B0F104,
    0x00D20400, 0x025E3BDE, 0x04D345E2, 0x018BF484, 0x01CA8482, 0x028858F9, 0x01F5B2E3, 0x04ACFF22,
    0x020A29ED, 0x01F8CCAE, 0x03499341, 0x04B65B2D, 0x03931A4F, 0x04BA6E71, 0x0596DDE4, 0x02536DA0,
    0x0174F303, 0x02ABCF81, 0x0166FDA4, 0x048FBF50, 0x0128C9C7, 0x022ABDCC, 0x0111DFE3, 0x004B016E,
    0x0264DCFB, 0x04847AA6, 0x004D1CB2, 0x047BA18E, 0x03EDD828, 0x0593CCAC, 0x01D2A0DA, 0x04551A7D,
    0x05A2787D, 0x02048CB9, 0x031C3B7F, 0x04AE7F60, 0x03F4D953, 0x039D3A22, 0x05F0EA4E, 0x04D3908B,
    0x032FA330, 0x01259424, 0x039F75DE, 0x04BE8457, 0x040F4C03, 0x0303B345, 0x05B140FF, 0x01BF2805,
    0x00D017BA, 0x03CFAAD1, 0x008E524A, 0x023F7199, 0x01E75C60, 0x014F0630, 0x01C47E1F, 0x03E72B7E,
    0x01897CAB, 0x03D141FF, 0x02E17CEC, 0x01D3F63C, 0x0289560F, 0x02FA8C54, 0x0288414C, 0x02B17882,
    0x0469F0B3, 0x049BB523, 0x0362455F, 0x01DB75ED, 0x01A50666, 0x04528A23, 0x00046B14, 0x00DCF858,
    0x01262F92, 0x032FC202, 0x030A65C4, 0x0234CC21, 0x0310237D, 0x0094E465, 0x006162CB, 0x0028C746,
    0x0118AF7B, 0x04D14D8B, 0x04EE7767, 0x000D31FE, 0x00B3EDEE, 0x052572FC, 0x05D28D7F, 0x01DB9DD7,
    0x0343EA82, 0x03798690, 0x014E4480, 0x0129D84F, 0x00177D68, 0x019E7658, 0x02D06FFF, 0x022CC5E8,
    0x02A1EFA9, 0x009A9FF6, 0x01631223, 0x03A3B8B8, 0x013866EB, 0x01AC142A, 0x01161687, 0x025B514C,
    0x0020BDEC, 0x009434E6, 0x00F09C43, 0x034EAD99, 0x01F4DB75, 0x0095DD63, 0x04928BA1, 0x04B3519C,
    0x0543EA4A, 0x059BD982, 0x0124A298, 0x01E99AB8, 0x029A364A, 0x02D586B7, 0x0069BE90, 0x01A2E8C3,
    0x05B86E70, 0x002591F7, 0x0472E228, 0x03586E4A, 0x017AD76B, 0x0240952D, 0x04BFECA8, 0x03117CD1,
    0x000E59B4, 0x0060A041, 0x04FF2B79, 0x043C700F, 0x02B466F7, 0x046B1A69, 0x04D3E38E, 0x006B92E2,
    0x01F9EB7E, 0x018C0C61, 0x007FCF48, 0x01A99446, 0x05CA0D24, 0x006C707C, 0x03D95DCC, 0x010D7BAD,
    0x0579D99C, 0x01879A7A, 0x02B36BB8, 0x01CCA749, 0x02F48117, 0x03AA03E0, 0x057B5188, 0x03066A8F,
    0x00CCEFCF, 0x054424FD, 0x0441E74C, 0x056632C8, 0x0507E5B8, 0x03408AF1, 0x0035A238, 0x04F1C327,
    0x056B7C8A, 0x036E3F61, 0x020E3811, 0x0194F58C, 0x03FF64B7, 0x00CE5A53, 0x05418ED7, 0x03902DA8,
    0x039546A1, 0x0084884E, 0x059AF77D, 0x04A8A9A6, 0x037C3C37, 0x0295F546, 0x02438394, 0x04487EC3,
    0x0533C741, 0x02197E1F, 0x0253D854, 0x030EC754, 0x015EF107, 0x006C36F1, 0x02B2DEB0, 0x056BDE8C,
    0x0515F8EF, 0x045BB2F8, 0x01122D13, 0x04D7F2DB, 0x00EC78DF, 0x00F778E9, 0x01DCB503, 0x035C989F,
    0x0591FFD8, 0x01DF1148, 0x0254B9C6, 0x056A8D52, 0x05C34588, 0x04FF26EC, 0x035F2512, 0x023CBDAF,
    0x02E1100A, 0x03F80F6B, 0x022A7C3A, 0x025FB31A, 0x0442C47A, 0x006BDCBE, 0x03B397BD, 0x036E78A2,
    0x02C174D5, 0x0442424D, 0x0094DB22, 0x01E7416F, 0x0569F1BA, 0x00EFA0A9, 0x039055B4, 0x05D6558B,
    0x00BEB73E, 0x019E5314, 0x005416F9, 0x002F1F5B, 0x010CC24B, 0x04280AD1, 0x03A9C99E, 0x02988B74,
    0x02623B63, 0x00331A78, 0x02F1BB9C, 0x04747041, 0x050C76FF, 0x024975A4, 0x04B59D02, 0x0480B7B5,
    0x00206B0A, 0x0170A6B9, 0x0334A909, 0x0313444C, 0x02092119, 0x0332FE0E, 0x022EC18D, 0x05C955A1,
    0x0456A783, 0x05BABCA7, 0x048E3682, 0x04E3EBBD, 0x0541C165, 0x020E07CD, 0x034A1DF1, 0x007EEC0B,
    0x049D8E00, 0x00F4E693, 0x03638F7A, 0x04137F6C, 0x03CAC327, 0x0574B2A6, 0x058482E8, 0x016E8CAF,
    0x01ACFA3E, 0x03EBDB4E, 0x022C949F, 0x039A1A28, 0x02A8A2C4, 0x04D7CF0D, 0x00A8D37A, 0x00CC1AE4,
    0x04285EB9, 0x018402B0, 0x044D3EC9, 0x000D53E6, 0x05DDDCE4, 0x0141223F, 0x05EDB1DE, 0x0103F3FE,
    0x02AE8E5F, 0x042E6C0F, 0x02392FBF, 0x01B6DAE2, 0x0036C220, 0x056495FD, 0x045FE487, 0x00A22F22,
    0x05854C0D, 0x006F3AE7, 0x056951F7, 0x00BD9B13, 0x02828A66, 0x05344B04, 0x00DF274E, 0x0061DE13,
    0x048EF80E, 0x0532ACD8, 0x03AE7319, 0x0497036E, 0x0451EB58, 0x0355C721, 0x04BBE714, 0x03281574,
    0x02F8AC50, 0x026C9ADB, 0x038B5C3D, 0x01AF203A, 0x05DCE0A5, 0x05D6CAE4, 0x04CB9EFC, 0x05F3A160,
    0x00E96B81, 0x03CD7707, 0x0078CAF4, 0x00801227, 0x02D58ECB, 0x0539B90E, 0x003F8D82, 0x051FA18E,
    0x010BA0B2, 0x03A8CE60, 0x04914111, 0x0096D434, 0x052DDE72, 0x009497E2, 0x04D65CA7, 0x013547B1,
    0x02F21C6B, 0x04E2C84F, 0x044F0944, 0x027FD56A, 0x0163C098, 0x0007A5B6, 0x033BF069, 0x05D2E8EE,
    0x0179B843, 0x030DAED8, 0x03BCC025, 0x043578A9, 0x045F0797, 0x046B025B, 0x05AAC2C2, 0x00F48EF9,
    0x05C6E025, 0x0000F273, 0x02227238, 0x04396410, 0x0084043C, 0x050E6E36, 0x0570C962, 0x0305B955,
    0x05CCA53A, 0x01C12916, 0x05D0BE8B, 0x042E8E09, 0x03644715, 0x04CDE24F, 0x04AA0FE4, 0x05D1A259,
    0x031E914D, 0x018DE604, 0x0167BC50, 0x01F36CE5, 0x04F30AB0, 0x009C0191, 0x0505DD80, 0x01BE0A0D,
    0x003629B4, 0x0089F5EE, 0x0292DE3A, 0x01C9AB27, 0x037AE08E, 0x03A55F76, 0x04A55258, 0x02126501,
    0x016AC623, 0x0534E552, 0x00D85FD3, 0x0397F9B1, 0x0188E822, 0x03AF0A85, 0x02B399F0, 0x0199A789,
    0x025E3BC1, 0x018BF200, 0x05BB1FD7, 0x03DD2D48, 0x047725F5, 0x00BC2D7B, 0x036A214C, 0x028791C4,
    0x0459F17D, 0x00A5C969, 0x03EE5EB4, 0x052FBD61, 0x01C398F6, 0x05BF3A17, 0x016E47D5, 0x01742CB0,
    0x04CF2CCD, 0x059D5D57, 0x056A6CEB, 0x0091CB92, 0x035597C5, 0x00CFD8B2, 0x04DA013E, 0x05742CD5,
    0x014A1408, 0x01AAEF8C, 0x01426D5A, 0x0512A00A, 0x01B82E78, 0x03F7A5DA, 0x05B29733, 0x031A2C7E,
    0x05E55519, 0x02676659, 0x03B0A418, 0x039CE0E6, 0x0425BFA3, 0x02D8B346, 0x0316AFA8, 0x05A5705E,
    0x04999511, 0x0082A51D, 0x00E85D77, 0x010F4E3E, 0x03824AB4, 0x03CC5E7C, 0x0077611F, 0x0110C659,
    0x047DE8B6, 0x05B3D84E, 0x0192539C, 0x0071F030, 0x00959FA0, 0x03890643, 0x030B9AFF, 0x03D27418,
    0x0044A4A6, 0x043F444E, 0x00D350A5, 0x0599893C, 0x0363ADAB, 0x058D82DC, 0x00F3AC48, 0x015FB160,
    0x037801BC, 0x0374F87E, 0x059AF676, 0x03D1D946, 0x024F7795, 0x04345C50, 0x02A4688D, 0x053B9880,
    0x00AC552F, 0x03C266A4, 0x00251AB4, 0x048E624C, 0x03BDB74E, 0x022D1B42, 0x0591F830, 0x02166E0A,
    0x0450A8EC, 0x015A17B2, 0x04128196, 0x031E2406, 0x0023EF50, 0x04B13A8D, 0x05C8AA87, 0x01E42528,
    0x029AB54F, 0x05360187, 0x00CC434B, 0x01EFC34D, 0x0432E979, 0x01DEE277, 0x013863A3, 0x01371118,
    0x00301756, 0x03DE0B82, 0x044071A4, 0x04C743C6, 0x028B168C, 0x05291702, 0x001BB384, 0x05833C51,
    0x03DC82E0, 0x041E1392, 0x03179E4E, 0x05B7B54A, 0x04AD938C, 0x01F2EF41, 0x0191D83B, 0x02453D49,
    0x048C54E8, 0x02E8B580, 0x05BB5E4A, 0x04409F6C, 0x03F33167, 0x0127FC07, 0x045F58B3, 0x029B5D6C,
    0x0353AB7E, 0x044E97AE, 0x030FCD6A, 0x05EBE392, 0x020046B9, 0x03E42C12, 0x0461F353, 0x0342C05A,
    0x0354780B, 0x0347A827, 0x0536BEB4, 0x000FDA6E, 0x044CBE9C, 0x04C2192C, 0x032AF8C7, 0x02F865AF,
    0x020DDB56, 0x05934876, 0x04D1E6BF, 0x033AFB2E, 0x04DE038B, 0x004EDB5B, 0x030AEE67, 0x04937621,
    0x038A29ED, 0x03ADE515, 0x0453BA2A, 0x02B897C0, 0x04F80B2E, 0x05691002, 0x03BA3D96, 0x03120FA9,
    0x018D1155, 0x01C76BE0, 0x022F0B55, 0x04C7CF18, 0x025C6566, 0x018357DA, 0x0586DB93, 0x001C065F,
    0x01492CA2, 0x05A47545, 0x004347DC, 0x016907BD, 0x03EE3FC5, 0x0377DC3D, 0x023E80AD, 0x01DA64CB,
    0x03CF779A, 0x05A6D36B, 0x02B86A44, 0x03836D21, 0x0254F886, 0x049233EF, 0x03483533, 0x0166E0B3,
    0x02F9B5C3, 0x03827779, 0x02ADDF25, 0x05D2FD30, 0x0483357C, 0x0498E088, 0x03B96AA0, 0x02083C4C,
    0x05D8A17E, 0x0255F200, 0x0336DC70, 0x01C9E780, 0x05DEB3FE, 0x04676EDD, 0x047FB624, 0x02C178CF,
    0x05280492, 0x01977E63, 0x04ED81AF, 0x021745E8, 0x0515790D, 0x01FD1626, 0x057BF860, 0x0194D2E2,
    0x04B9EE87, 0x04E58437, 0x0450B4E2, 0x0203E9EE, 0x018056AA, 0x020FF146, 0x02739770, 0x05621411,
    0x00A6907B, 0x04FA465A, 0x0012D953, 0x014124D6, 0x009CAC9A, 0x024A1A96, 0x02972483, 0x05945C34,
    0x05D72E64, 0x00C833F0, 0x04E43F82, 0x0492900D, 0x02D6A496, 0x01012350, 0x0465A43E, 0x040F209C,
    0x00092313, 0x041A5DCF, 0x0229AF22, 0x02536509, 0x014C3E06, 0x05EBC9D8, 0x04A2476A, 0x00D04601,
    0x01B7FEF5, 0x04CBEFA1, 0x03B41D9F, 0x0367F3BA, 0x026DDC92, 0x0391C0AC, 0x01D57647, 0x036B41B9,
    0x04903ABE, 0x03AD027F, 0x0495DD7A, 0x01FA9134, 0x0302E0B0, 0x050585BE, 0x02465228, 0x0284C872,
    0x02931333, 0x00882CA8, 0x03ED7968, 0x050410ED, 0x0156FB14, 0x00E7AF97, 0x058D51A1, 0x0572B7C0,
    0x0212ADBD, 0x04D4337E, 0x03AA2F3E, 0x05F209CD, 0x04D93B51, 0x00E85885, 0x009BAF45, 0x00F8EF4D,
    0x04101754, 0x03E94118, 0x0362B5DB, 0x01B484E5, 0x01873B5C, 0x05D36D14, 0x00ABB00A, 0x04A97F60,
    0x03B08D67, 0x0283AE89, 0x001031A8, 0x00DF785B, 0x04D34F40, 0x03C6250E, 0x00DC903F, 0x041BC2BE,
    0x03E2A4DA, 0x03482DBE, 0x0294DD71, 0x03372D80, 0x04D58830, 0x011E789A, 0x053A420D, 0x00DAB0A2,
    0x028B7071, 0x0477CCAA, 0x00520E65, 0x03896340, 0x03DA1E2D, 0x05CD84CA, 0x01A5C729, 0x03D54297,
    0x03981024, 0x01CCC0FE, 0x017DB3F3, 0x02A2C949, 0x05B3AE4E, 0x00597ED2, 0x05C30054, 0x04C4FCC3,
    0x05290332, 0x00B22AB2, 0x05210B5F, 0x041EECB1, 0x048E67B5, 0x01603510, 0x001300C2, 0x017C0E3F,
    0x032F6065, 0x00734F7A, 0x02623142, 0x00594DFD, 0x03F2E2A6, 0x00613139, 0x001D8B51, 0x0327B299,
    0x05E645B8, 0x02940734, 0x03B93FA1, 0x025678CE, 0x0310F981, 0x03DEB76F, 0x023B237F, 0x008D363C,
    0x00EF6AC2, 0x03B38F34, 0x013B0279, 0x03E8451B, 0x00D8B42E, 0x04C338C2, 0x0193BCA5, 0x002827A4,
    0x01EDC164, 0x0501EE85, 0x04DC3ABF, 0x00E82132, 0x02FE2FD6, 0x025C3C2D, 0x01E1522B, 0x0459115B,
    0x02C959CA, 0x053F6177, 0x02F5A617, 0x0026C54A, 0x0252D843, 0x00491994, 0x03CD029E, 0x024D24BD,
    0x0291B14C, 0x05827398, 0x044C9120, 0x03A5E23A, 0x04C818E2, 0x0107E584, 0x007E3897, 0x03116DFB,
    0x04B71650, 0x014F461C, 0x0125B669, 0x050CC493, 0x04432AB4, 0x0410FFA7, 0x0347ABCF, 0x03075B74,
    0x04E535B3, 0x018592C5, 0x0115ACE8, 0x046E8476, 0x036BA336, 0x001E9144, 0x04B98469, 0x04248427,
    0x05A967C9, 0x03CE4588, 0x006D6FA0, 0x05E6A5AA, 0x02C57D1F, 0x05C749F5, 0x00A9BC58, 0x038DA02E,
    0x035F55A1, 0x0206B0D1, 0x02B0F7FD, 0x046053C6, 0x009BC016, 0x0522B732, 0x0243824B, 0x00AA1DA4,
    0x03E90D20, 0x03548BBC, 0x04F8D9F5, 0x05012565, 0x025FA017, 0x0105E675, 0x0346B7C7, 0x0381C107,
    0x03D9D788, 0x007AB17F, 0x04266031, 0x0059B2EE, 0x00398F3D, 0x049C19DD, 0x05A9DB63, 0x026F1399,
    0x04617302, 0x05F07F59, 0x0435AF73, 0x006EFE68, 0x0371A67E, 0x0483178F, 0x003C4C17, 0x03E00B22,
    0x03D4F8A6, 0x01C338F6, 0x01366CA2, 0x0238375B, 0x0445D47A, 0x015C3C54, 0x013CA6A1, 0x03A005B4,
    0x058D514F, 0x059E2184, 0x05F3746C, 0x0583244A, 0x0061089E, 0x03677322, 0x0421C647, 0x01D7EAA6,
    0x05389668, 0x02390351, 0x03759CC8, 0x01C97C6D, 0x0502D74E, 0x04DC4DC1, 0x04C384A6, 0x011DF3BA,
    0x05137305, 0x0300E926, 0x017978AB, 0x0211FDE8, 0x04DE4779, 0x03128231, 0x00410A8F, 0x040C3CB0,
    0x0486CC8F, 0x04303D3B, 0x02E25C4C, 0x00B31905, 0x029E5BAB, 0x0083AFE5, 0x04C2E563, 0x006966DC,
    0x0289AD6E, 0x01B464A1, 0x00B16FAB, 0x05C00443, 0x00A310F8, 0x0416B52D, 0x02A1344A, 0x0034DBF5,
    0x03669DBC, 0x03E285CD, 0x026CD490, 0x02EB2E58, 0x003A1B48, 0x05E5D476, 0x0530EB65, 0x04DB1DA3,
    0x041D14BF, 0x0329351D, 0x04EE43C1, 0x018D3811, 0x048C92C8, 0x024D63CB, 0x05EC1121, 0x037B8BC5,
    0x02CA13AD, 0x01B478C4, 0x01EBD5B7, 0x01AD6866, 0x04069E4E, 0x00788D05, 0x03630080, 0x045B3A93,
    0x03D93BC6, 0x054049B7, 0x00FC2FC5, 0x00D50F36, 0x01AD6F6B, 0x02ED8390, 0x00CC58B0, 0x00DD98DC,
    0x054D3485, 0x00F867C9, 0x00154DD4, 0x03E5473F, 0x0283ED9D, 0x04F8C08A, 0x03CA2655, 0x03BF8422,
    0x0404DE9A, 0x0092BAF0, 0x0116AD73, 0x003A9F39, 0x03BB501D, 0x032ECE0A, 0x03C1BAA2, 0x0493F720,
    0x028D2E50, 0x007B6DF9, 0x02B366E3, 0x01581605, 0x039F857B, 0x04305A28, 0x05AB1BBB, 0x0547975F,
    0x031AD075, 0x017ADF67, 0x0364C38F, 0x003D109C, 0x00420851, 0x019C7D3A, 0x048BBADA, 0x0435C74F,
    0x04BEA449, 0x0000FBAC, 0x011C4352, 0x057B5DE6, 0x0554D6E5, 0x03C8CD8C, 0x05E8B726, 0x02281C25,
    0x048B3AA7, 0x00D0777A, 0x03F1017F, 0x02077933, 0x02E3373C, 0x0592CB24, 0x053E01FC, 0x01505A2D,
    0x01D049B3, 0x0411B1D8, 0x023A9ABC, 0x01752CE2, 0x04A9B459, 0x040B186D, 0x00B6DBCD, 0x026A799A,
    0x0109EA84, 0x05B167AD, 0x01562C3F, 0x05D2BDBE, 0x04013FEA, 0x03C030A3, 0x009FA63E, 0x0591B459,
    0x0549B0BA, 0x01891120, 0x01A65D32, 0x027217F8, 0x00C1A1D5, 0x05AE573B, 0x0543FC78, 0x056317B3,
    0x037F5F32, 0x04DE5A24, 0x02D5E7F4, 0x052FEAA7, 0x05F38D70, 0x00594E89, 0x04ABF149, 0x000DFD6D,
    0x02BA88C1, 0x05080EAD, 0x02B3748F, 0x02D82B37, 0x0203C93A, 0x039D5549, 0x029548DC, 0x05C7F591,
    0x01E42566, 0x025761CE, 0x042D8A9E, 0x02ECE6FD, 0x05B5E634, 0x015AC11B, 0x04AB16BF, 0x00C1CBE5,
    0x001644E3, 0x016B9909, 0x02C35EC9, 0x047540DF, 0x0024E8F1, 0x0588109D, 0x04F28142, 0x04C73957,
    0x027B484C, 0x001136C5, 0x05029292, 0x059D7A4E, 0x05467CA4, 0x04F48D1E, 0x031E399B, 0x00CC2D31,
    0x01E36EB5, 0x039471A4, 0x048B27A3, 0x00118EF9, 0x04DA2AB0, 0x05E7D6CB, 0x007C8527, 0x039B0185,
    0x0230B1CF, 0x049C4BC4, 0x02909827, 0x006CBAF0, 0x047594AB, 0x043209A0, 0x02B58003, 0x05DE903D,
    0x02D11065, 0x043008BF, 0x00F06866, 0x00E01BA3, 0x00EEB596, 0x05E7C50C, 0x032ED9A8, 0x05099598,
    0x020EC806, 0x00906748, 0x02577E46, 0x02E0FD46, 0x051A2A65, 0x03465C97, 0x0219E2D1, 0x01940E22,
    0x004AB4EE, 0x0262C35D, 0x033E8CBA, 0x039B4F07, 0x048F4F29, 0x050CF7B7, 0x0502C9D2, 0x0348B955,
    0x0341EF92, 0x015909E2, 0x01D30314, 0x00058CEA, 0x029E38E2, 0x014B6015, 0x01A12B45, 0x002082AB,
    0x0337FF20, 0x0192CD07, 0x01AF810E, 0x0494E8D7, 0x03D2BC0B, 0x001B8461, 0x02CDFECF, 0x057DEE2C,
    0x01E3D48D, 0x056B5C05, 0x01B4EA0A, 0x00E610DA, 0x000B0ABA, 0x01DD2A52, 0x011C5EC3, 0x0408017B,
    0x057C5B51, 0x037B1673, 0x0299D501, 0x02D063A8, 0x00627146, 0x05BD0163, 0x05328452, 0x00095179,
    0x01139DAC, 0x02D54406, 0x01FD70A3, 0x044F4FE1, 0x007025E9, 0x01B08763, 0x03F20C11, 0x02491F83,
    0x02448B6F, 0x015E9E18, 0x03FF5170, 0x03E0C821, 0x058BD5AA, 0x02D55CE8, 0x03C188A6, 0x051F0E5C,
    0x0434A855, 0x01E5EC1E, 0x05E6C550, 0x037F708B, 0x05590863, 0x0152706A, 0x00777A22, 0x05B41D5B,
    0x04FB6FE2, 0x0545DC80, 0x03442E65, 0x046F25B8, 0x02E2326F, 0x0454E5E0, 0x041C9FEF, 0x02770713,
    0x01C3A22F, 0x01874A2D, 0x0182157B, 0x0585862B, 0x03763AD9, 0x0528DFFF, 0x04260B1B, 0x04DFBB15,
    0x045D28C2, 0x041E344E, 0x04107DF1, 0x00BABECF, 0x03ED367C, 0x05BAD14A, 0x0202DCAA, 0x01DDED14,
    0x02C16028, 0x053255ED, 0x03D6312D, 0x032A3D03, 0x02A6D034, 0x03EBC893, 0x05A838C9, 0x02D04BDC,
    0x047BEBD7, 0x00D8F37F, 0x02C6EA1D, 0x028E43C7, 0x029DDA9F, 0x04BD5DD0, 0x005D3C92, 0x0462AA43,
    0x05F0B8FF, 0x02D68F60, 0x035C3078, 0x056C4D27, 0x01900C65, 0x0072B1FE, 0x00CC7E69, 0x051FB128,
    0x042374DF, 0x048A2D81, 0x0461608A, 0x0200BE88, 0x0594F966, 0x03367C8C, 0x0582BDB3, 0x03788B38,
    0x0195F623, 0x037D1C31, 0x0059C3CA, 0x0035983A, 0x04A1178D, 0x02D5FFE3, 0x00DE3CD7, 0x009F93B7,
    0x047CD443, 0x01F54F4C, 0x013C1FB3, 0x0116BFB7, 0x03485FAE, 0x01BC3527, 0x02B153B5, 0x04348A9C,
    0x00EF7758, 0x032862C8, 0x04CA5D0D, 0x012E37D6, 0x0337BB57, 0x0012C315, 0x03152F0C, 0x01273BA4,
    0x00720442, 0x04679928, 0x01CF08AB, 0x01E79C5E, 0x03DC9D83, 0x03869A29, 0x04E0A9CE, 0x01F8C26E,
    0x05706494, 0x035BB7F8, 0x0592219C, 0x019B899F, 0x016DF781, 0x02C5BD67, 0x058A8E29, 0x030688E2,
    0x01F33E21, 0x0011FD25, 0x04FBBF4D, 0x0405DE63, 0x05ACFEA3, 0x00FB852C, 0x0103A393, 0x006B1B5A,
    0x0383FB7A, 0x0224450A, 0x0241644C, 0x0265698A, 0x00EF7279, 0x0502DED6, 0x0197AC51, 0x02F270B9,
    0x04A81D88, 0x038D2FAA, 0x03204A6B, 0x006BFD1C, 0x0456F8BF, 0x034DAC54, 0x001BD5FA, 0x01594FB9,
    0x0130030F, 0x0140BAC2, 0x05C2BB6F, 0x0489DB48, 0x05D28C6D, 0x05951C94, 0x0381835F, 0x043BE715,
    0x02197F5E, 0x016CB9AB, 0x03CA7B89, 0x0154C2E3, 0x04422C8E, 0x0390E057, 0x0235327E, 0x046561F8,
    0x04F06646, 0x0355D542, 0x055DF700, 0x02C0CD0E, 0x00C00D43, 0x049BA1E0, 0x037CDF78, 0x01261F34,
    0x03B9D311, 0x041F98A6, 0x04EB0D29, 0x002766B3, 0x028C7534, 0x05936485, 0x00F11EA1, 0x0352ECB5,
    0x0356A445, 0x03E6700F, 0x049F5767, 0x05B56BAF, 0x0270EFA0, 0x057C7C79, 0x0334A350, 0x01290D51,
    0x00C612D5, 0x014F2968, 0x01A43F4A, 0x01D1DA93, 0x02E3587D, 0x05D26174, 0x03703C12, 0x02C94349,
    0x03860C77, 0x03AE292A, 0x0335F3B7, 0x00FE84E2, 0x01CFD233, 0x002D40A4, 0x00550980, 0x025CB9BE,
    0x025A72D2, 0x007D9A82, 0x01E026BF, 0x0342D90E, 0x054F2E02, 0x0168BFF4, 0x005A529E, 0x05DAB7F3,
    0x02784EC5, 0x00FBB0A7, 0x052CCCCE, 0x012D4276, 0x02AC0EFC, 0x03743BCC, 0x04750069, 0x05CAE22B,
    0x01ED0745, 0x0175C447, 0x0103363C, 0x05C37084, 0x0161C186, 0x025B3E4F, 0x02EF3DEF, 0x032ADF9C,
    0x03B7CD83, 0x03737E24, 0x025A937E, 0x049DBA3C, 0x0422C41D, 0x014B9B71, 0x051D63A9, 0x02A0E2C6,
    0x02B05BD5, 0x021A6389, 0x008DCFF3, 0x00D7F734, 0x01856C0A, 0x02E56D2E, 0x01D143F1, 0x01FF3C11,
    0x042D784E, 0x008999DC, 0x039F0CE5, 0x03A51A79, 0x039A07ED, 0x01BAB900, 0x0289E2F0, 0x01296D93,
    0x040CB98B, 0x02814911, 0x04E85B48, 0x01339553, 0x0470BFE0, 0x047A7EF8, 0x02C96F1B, 0x00CAAFBE,
    0x01D41466, 0x0282E5A0, 0x01FB0240, 0x011BCABB, 0x010A8E7B, 0x016EF28B, 0x04186D97, 0x025C0CDB,
    0x01503481, 0x04AD25A1, 0x0407BF32, 0x027F9BB5, 0x001073DD, 0x0489E8A5, 0x05238342, 0x01F71862,
    0x035E9C74, 0x044BB88C, 0x017E2E58, 0x0325A31D, 0x00DEE898, 0x00FD3C58, 0x004E34D8, 0x02E39BEB,
    0x01EAD30F, 0x01F22F36, 0x059CEC84, 0x00321030, 0x05D3BA6E, 0x00636F07, 0x0340A2AA, 0x039B3F19,
    0x02408E7D, 0x05C5B740, 0x012EAD75, 0x0151631D, 0x007FCFC0, 0x03DA028E, 0x022BB454, 0x0246D6D8,
    0x0196583F, 0x045D9BCE, 0x0034AA10, 0x04A35EDB, 0x049110AA, 0x038DDD31, 0x013FD894, 0x05018C45,
    0x0513AE81, 0x00336328, 0x05DD806A, 0x0372488B, 0x028F9AFA, 0x033A9A1E, 0x0571FDAC, 0x0330F1BF,
    0x049C0E85, 0x010147C2, 0x02C911EB, 0x0469D482, 0x03E70384, 0x052BE069, 0x055A2A81, 0x04FCD26A,
    0x01CC3937, 0x05BEC6F6, 0x02C069F5, 0x02E3BAC8, 0x00992DDF, 0x012EB934, 0x050E3B90, 0x02813AE6,
    0x0000DA68, 0x030CA777, 0x01510A86, 0x027FBF37, 0x00F3B538, 0x03A6B6E0, 0x00C7B853, 0x01D49DBA,
    0x012813A8, 0x0459E19B, 0x04E57AAD, 0x007FE793, 0x028EDB69, 0x02B1A675, 0x02731525, 0x01174944,
    0x04F9CCA1, 0x02C001FA, 0x04DFD5F2, 0x050F71AF, 0x02A793E7, 0x04F0F39F, 0x0097A515, 0x007AD40B,
    0x023CF053, 0x012F64D8, 0x052CC8C9, 0x03713FD5, 0x032BF864, 0x00539BAD, 0x052CC10A, 0x01496E78,
    0x01CD7A08, 0x0402D8C9, 0x00F07269, 0x01846995, 0x00513446, 0x003BD6F5, 0x00275C90, 0x004ECF72,
    0x057CF1D4, 0x03AEBA2F, 0x0277A2E6, 0x00FD3F0A, 0x059D6EE4, 0x004FE681, 0x030136BE, 0x05D23261,
    0x022A72E6, 0x02D53C75, 0x03B77A71, 0x05595647, 0x0593FB96, 0x02E02685, 0x01657863, 0x03E093D4,
    0x02A5081D, 0x04C24A71, 0x04978846, 0x058F8A69, 0x05A67A94, 0x00FA4AD3, 0x0462C37A, 0x05B4058E,
    0x035DEE0D, 0x0157103A, 0x041DEBC9, 0x01D6E7D8, 0x03339711, 0x054C896F, 0x029E5D68, 0x05BE94B0,
    0x054CCD62, 0x0057A586, 0x023B4CE3, 0x057085E2, 0x01AA1DB7, 0x039FBBE8, 0x05CBCA9B, 0x0358083C,
    0x03B1FB70, 0x03D04C5A, 0x05B494AC, 0x0317C481, 0x04B2D233, 0x01D8E046, 0x00A7EFCE, 0x03BC14BA,
    0x025AB745, 0x01002240, 0x04F72A35, 0x046E0768, 0x01FF8E03, 0x0370E6E3, 0x00C9467F, 0x0102DBEE,
    0x00D4CA7F, 0x05AD8031, 0x007F1CBD, 0x031449F1, 0x017BFC9A, 0x013947E6, 0x03924937, 0x03DDE2B3,
    0x0554FD4E, 0x0345D819, 0x0404F35F, 0x03E42F77, 0x023CD172, 0x0423A4A0, 0x04888318, 0x0284C986,
    0x051BF560, 0x03B3B789, 0x032A3206, 0x001754B7, 0x00DF0BB2, 0x02B01E43, 0x01CEBF86, 0x05225FA9,
    0x03323083, 0x05728057, 0x01FA653A, 0x01CDA1B4, 0x00307DA1, 0x05178A7E, 0x0117E938, 0x03CFAC83,
    0x05479D0C, 0x04F2DCD9, 0x02A2EEC0, 0x00298C1E, 0x04DAAE0C, 0x05B2B867, 0x02268873, 0x0564FB21,
    0x04F67966, 0x01EAF6AA, 0x0561F06E, 0x056C9092, 0x04BF6869, 0x025A6739, 0x04444CF3, 0x012BCD11,
    0x01A0DE10, 0x01C9E9CF, 0x024D1243, 0x05349684, 0x00E77CEA, 0x03FE89FF, 0x04A58854, 0x04FD2CD5,
    0x01CE605E, 0x04517EC3, 0x04879C44, 0x03FA7227, 0x0386F263, 0x0369E5D2, 0x00F0FCC1, 0x02ECAE51,
    0x05A90DC1, 0x0385ED6A, 0x05788603, 0x021B96AD, 0x0214D7AD, 0x034EEDE2, 0x03D1DFB6, 0x01BCCDD7,
    0x03FE685A, 0x045F2944, 0x0229ABC7, 0x0304BFB7, 0x0412E2E1, 0x00372C75, 0x05F573B6, 0x0140C544,
    0x0240D643, 0x048CCECB, 0x01B64687, 0x011BD00F, 0x00A60A1C, 0x0006CD62, 0x030EAD62, 0x00F90577,
    0x04531973, 0x01FCB1C0, 0x03BB91A5, 0x00AF8670, 0x051FD895, 0x053F6C0B, 0x02F04FD4, 0x04521F87,
    0x03AF12A7, 0x0268D17E, 0x059CF4E9, 0x04BD64AF, 0x023B8716, 0x04BF68C3, 0x0239DE1E, 0x01E01E96,
    0x0337FBF1, 0x05A8ED71, 0x037AD5F4, 0x0300FC79, 0x03249C93, 0x02343DEF, 0x03B0140B, 0x048533F0,
    0x0105E788, 0x050B632C, 0x02AFB9DB, 0x03883BD1, 0x03CC563A, 0x00DFB080, 0x015558DC, 0x01633D20,
    0x05554EC0, 0x004C9324, 0x046E6640, 0x055077C4, 0x05C79548, 0x0528B145, 0x00A97243, 0x04F0B9FC,
    0x01EFCD10, 0x02AE3250, 0x0036DE5A, 0x01DD0380, 0x006702A4, 0x03D5B48F, 0x036C491E, 0x05C23C07,
    0x047E6002, 0x0512B92C, 0x046EA5B2, 0x0128FE43, 0x01E02B39, 0x02D1F66B, 0x04B6A50E, 0x045124B3,
    0x055DFAF7, 0x02A3A819, 0x01BD056D, 0x05064EF7, 0x007A554E, 0x0262D2CF, 0x05280E6D, 0x028E2287,
    0x02E89BB4, 0x022241F8, 0x04E00FB1, 0x04083F8B, 0x04B92383, 0x006CB9C9, 0x01EAEC12, 0x05B0ADD7,
    0x03928F66, 0x03DE211B, 0x00EDC5FD, 0x0430B5FD, 0x02A16CF2, 0x04EF13A5, 0x00C44A68, 0x006406EF,
    0x054F005F, 0x00485F2D, 0x03829987, 0x03D9B077, 0x054B85CB, 0x003E42FE, 0x05A42DAE, 0x05632C4D,
    0x01703E11, 0x04EABB2A, 0x033FBA05, 0x0158BBB3, 0x04B1172E, 0x00CA2882, 0x058A6F15, 0x00BB63C1,
    0x0430542B, 0x01EE069A, 0x019A4BB0, 0x04A12EB9, 0x0092D5DA, 0x03A240A0, 0x036B3325, 0x01AF8939,
    0x01363AC1, 0x00BC0229, 0x0106AC90, 0x0237C5BD, 0x03515070, 0x00BF6137, 0x056C2ED4, 0x018300F6,
    0x0282BB3C, 0x05CB9C34, 0x0082BD04, 0x029BA6B5, 0x05B2379C, 0x00297B61, 0x05A27214, 0x043DEC09,
    0x01963A6D, 0x04EE16AC, 0x05045110, 0x0073422A, 0x020B86D1, 0x03B61D5D, 0x045E6CDC, 0x00EFAF87,
    0x05B56510, 0x03CF6F76, 0x001465C7, 0x03829441, 0x01A7AC77, 0x005C1EB7, 0x0164A554, 0x036A60D0,
    0x02744757, 0x03843E37, 0x01612504, 0x012B10B8, 0x018E060B, 0x007A36E0, 0x00072A5C, 0x0469A7B9,
    0x00A461CE, 0x01770B00, 0x02B487EC, 0x02552947, 0x02D4B278, 0x02E20F6E, 0x00D03A0C, 0x00AF85E3,
    0x04626DF3, 0x05ADD9C0, 0x00BBE698, 0x037205C4, 0x004B0645, 0x01CC6523, 0x02A30B3C, 0x04A9DF1C,
    0x013B9CFF, 0x05465BDD, 0x0136ACA4, 0x03327288, 0x04186AE2, 0x0246CEA8, 0x04E170A7, 0x030EE596,
    0x02824636, 0x01E2B6A6, 0x001C5FE4, 0x04E7F40E, 0x02266FA9, 0x01C319FE, 0x0522A7C8, 0x018A4455,
    0x05E52DC4, 0x0481A94F, 0x04CDF7C8, 0x02C28A0F, 0x000163A3, 0x028B706E, 0x05080825, 0x0109F1DD,
    0x0317CACE, 0x00E25B72, 0x01ECC07E, 0x01544911, 0x03F18BB9, 0x00AE4F50, 0x035427FD, 0x0272A83A,
    0x01AE2EC8, 0x018D85AB, 0x01E3C689, 0x02326F96, 0x04B688A4, 0x0496F332, 0x01E23B05, 0x02E12C31,
    0x047BE43B, 0x02A102F0, 0x003AFCED, 0x0515D6A3, 0x01EE7648, 0x04119BF3, 0x037633D5, 0x00AE1254,
    0x05CE3529, 0x029D5228, 0x0384FFA5, 0x033E4968, 0x00FB4889, 0x00568383, 0x057609D2, 0x03307D7A,
    0x022CF206, 0x026AEDE1, 0x007881FA, 0x02C18C6F, 0x0505460B, 0x0511602F, 0x04EFCA15, 0x05EEACC4,
    0x034BE485, 0x04A8FDA9, 0x0053BE2C, 0x00382A21, 0x004B1391, 0x008FB647, 0x04EB564C, 0x03EFC636,
    0x0048E515, 0x00DD510D, 0x0105CCB1, 0x042A264C, 0x01E49614, 0x03628D43, 0x029A0E7A, 0x0366C95C,
    0x00D14515, 0x0438EBA9, 0x02029F5C, 0x05932155, 0x029E6362, 0x004A9D1E, 0x041868B5, 0x01EEA6C5,
    0x00FCB767, 0x03C3DDFC, 0x0149ABFA, 0x021676C4, 0x053F51C8, 0x01A45585, 0x0357FE21, 0x043457BD,
    0x00BF6D42, 0x012AE9BA, 0x03AEF294, 0x01080E57, 0x01D3770C, 0x01A6820A, 0x00D761ED, 0x02E00157,
    0x038A5B1A, 0x019E6176, 0x01CE1CE7, 0x011B5567, 0x01DC47A2, 0x0332BC46, 0x02F9A405, 0x01A69A77,
    0x059DF106, 0x01CD849E, 0x0048DCA6, 0x00E39FC3, 0x038ACD44, 0x015F6029, 0x00392F14, 0x012FAE63,
    0x021A6295, 0x01E98F4D, 0x01C9A7E1, 0x0126EA6B, 0x02664564, 0x04B5314D, 0x04145697, 0x019A0D63,
    0x02F9D900, 0x008377EE, 0x026CD3C9, 0x0148BEE0, 0x00497A4D, 0x0498CA53, 0x04237B4B, 0x055E88D0,
    0x01867DE5, 0x0328F907, 0x04C4CF99, 0x05DB3797, 0x00D2660F, 0x05A06B85, 0x02E2BA71, 0x012D7454,
    0x05F5C19F, 0x04AC50C9, 0x00A71EBB, 0x03BA6BEF, 0x04E97F20, 0x0276F07A, 0x04F5122B, 0x055359E0,
    0x01687C38, 0x0596E229, 0x02E8EF2E, 0x00C10F77, 0x04661916, 0x0013F8A7, 0x0405231B, 0x04154C6D,
    0x0077CD20, 0x017FDBCB, 0x01FC9D2F, 0x0044A2B3, 0x008DBE33, 0x025F7B98, 0x0533592E, 0x05EA1ECA,
    0x009690B2, 0x02580F72, 0x05103C00, 0x01BDEA35, 0x0186036E, 0x02F83CDF, 0x003982DE, 0x02BEC27F,
    0x0430D172, 0x00691906, 0x02DAC209, 0x03933F55, 0x05D8A4E0, 0x03363F21, 0x01191849, 0x0496EC01,
    0x019D3B12, 0x03628DD7, 0x0366E2F0, 0x05B6E989, 0x011E7653, 0x00AF4486, 0x0067FBB4, 0x05578A4A,
    0x0178978C, 0x0549A07A, 0x00610234, 0x05EC9111, 0x01171179, 0x03919A4D, 0x045A0150, 0x00C05C42,
    0x02E31B91, 0x05070867, 0x00FB98F5, 0x017168BE, 0x011663A4, 0x00C0204B, 0x005BA688, 0x01821DCE,
    0x01FD8CFD, 0x02281766, 0x0015C5A1, 0x000C9438, 0x058EB4CB, 0x02EAC847, 0x05046D61, 0x042406A7,
    0x05BBC44D, 0x05AB51E2, 0x04917D9B, 0x02651371, 0x01A2D38C, 0x01BC2106, 0x024B1450, 0x026D42A2,
    0x035231ED, 0x05156610, 0x025D7C87, 0x04B22944, 0x04F9F881, 0x01A6666D, 0x04EAF900, 0x059C677C,
    0x04494876, 0x0315D583, 0x03DC5A4C, 0x02705B23, 0x01801431, 0x04B24360, 0x019FB635, 0x0069A9D3,
    0x0017527A, 0x0474ED52, 0x00275E4C, 0x02627294, 0x04592D07, 0x05E0AA83, 0x043E3B05, 0x01D3E7D8,
    0x016D0C15, 0x01E822D7, 0x008E6EE5, 0x046564FE, 0x023717AB, 0x03D53D7E, 0x02D1B3EA, 0x0279D9CA,
    0x0434F3A1, 0x03EBBC0D, 0x02893FA0, 0x05AD3523, 0x05A77659, 0x01F5DB3A, 0x047FED2F, 0x03E8925C,
    0x01264DD0, 0x01A260AB, 0x02BC7257, 0x031F8C85, 0x02A9BA67, 0x02807D28, 0x0074E56B, 0x05EAF479,
    0x0145DFEA, 0x054EF11A, 0x001F0AD8, 0x01DCF52E, 0x05C227FD, 0x049C6006, 0x01211D03, 0x04735E7D,
    0x02248B8B, 0x031D7BAE, 0x050B44AC, 0x01AB7493, 0x040ED148, 0x0434D979, 0x003070A5, 0x04A7E88F,
    0x02056B74, 0x044483EF, 0x048A19AB, 0x00788BC4, 0x011C85B9, 0x02386C16, 0x03B52870, 0x05E55EA5,
    0x05CAD0A2, 0x051FE9D2, 0x01747D50, 0x0206523D, 0x05D07F91, 0x0420E957, 0x025FC79A, 0x053909AC,
    0x036E1153, 0x0379D131, 0x011B3A1C, 0x0281D311, 0x032C3E29, 0x04D881A8, 0x02D9179E, 0x022EE858,
    0x0354BDFF, 0x032E1094, 0x021D1E21, 0x01D273C3, 0x01D11E00, 0x050A29C1, 0x05B6F7EC, 0x0202379D,
    0x01F38463, 0x056E4848, 0x01FC74C1, 0x041D8698, 0x000F3051, 0x051253FA, 0x01BCA201, 0x054B152A,
    0x00BA5AE1, 0x00DD7C2A, 0x03ED69BE, 0x03F45D26, 0x053D846A, 0x05D8B8BC, 0x001EAF36, 0x0553A42C,
    0x04DEB23C, 0x053539FD, 0x02373F6C, 0x014BA97A, 0x047C4691, 0x00242CAF, 0x035B4EFB, 0x029E746A,
    0x01A85F2F, 0x003BE4D1, 0x002A58D2, 0x03EF1AD4, 0x01CF7969, 0x05681106, 0x03292CFD, 0x04F7B945,
    0x050D5368, 0x00957799, 0x05778868, 0x003FE939, 0x05C43662, 0x038C039E, 0x0297B83B, 0x0118C9A9,
    0x0241DD23, 0x01B12ECD, 0x05EAB423, 0x0192890D, 0x0217E712, 0x01CC55A6, 0x005FA60D, 0x050D6FB7,
    0x04D8FB11, 0x01D6B610, 0x04A8C606, 0x050DFECB, 0x01BF94FC, 0x0168FC84, 0x01A89C1F, 0x038BFD24,
    0x021DB709, 0x04477764, 0x0545EE05, 0x04C91064, 0x0367957A, 0x02F864F1, 0x03C0EDA5, 0x02F29503,
    0x009FA58A, 0x0193DDC9, 0x01F8CB1E, 0x033F272E, 0x031F15FC, 0x02D9B67D, 0x01A0CA7A, 0x03153FA1,
    0x030F5F51, 0x0263C765, 0x05B05DC7, 0x043FF3D3, 0x022CCA87, 0x00EAD718, 0x02158E86, 0x0384D682,
    0x04769F82, 0x0394A306, 0x04FA28F6, 0x029DC9A5, 0x0172C42A, 0x03F421A3, 0x03E5C412, 0x009909A7,
    0x0373265E, 0x030DA07B, 0x047F17CF, 0x0386A97B, 0x02CE4F55, 0x0553546B, 0x042F4C6E, 0x05A7BCCF,
    0x04F0F005, 0x04C7F729, 0x004D9306, 0x04D13127, 0x055EFE65, 0x0184CA08, 0x05CE9896, 0x0407DF1F,
    0x03BB0197, 0x00716A25, 0x03B51EDA, 0x025D55A5, 0x034AEC75, 0x00965FC3, 0x00FBAB2A, 0x0324E7FC,
    0x05C0881B, 0x02D384DF, 0x019180D0, 0x0149B95B, 0x02CFCC50, 0x024A223A, 0x056CC756, 0x008F0E65,
    0x052A1772, 0x0209DFCF, 0x02921877, 0x0486D9DB, 0x031CF317, 0x005AA2C0, 0x01AEB954, 0x021649C0,
    0x0121F033, 0x044BC0D7, 0x05515F9F, 0x000CE993, 0x0425CEAD, 0x0422D950, 0x00CB1D17, 0x0155F829,
    0x009184C7, 0x03055061, 0x0167B0CA, 0x030AB99B, 0x04611EE2, 0x05670A2C, 0x0135018F, 0x02199961,
    0x038704AC, 0x05DBBA08, 0x01C9AD5A, 0x0242FA26, 0x05CE4C3C, 0x03F00BD2, 0x030C0912, 0x01DEF656,
    0x016F8002, 0x03177057, 0x0333D8A5, 0x00656317, 0x05B0EB68, 0x03680B18, 0x022567CC, 0x047646D9,
    0x0016B2F3, 0x0299D62A, 0x00F44097, 0x04496E8B, 0x057E06BD, 0x0543C686, 0x03FEAA09, 0x0435A473,
    0x004102F0, 0x05CAAB81, 0x026B217A, 0x0184B890, 0x0209CB6C, 0x03323F1C, 0x029D80C0, 0x0358F215,
    0x04FF813D, 0x02AF29DA, 0x052C9554, 0x006D6BB4, 0x0152625F, 0x05B92A3F, 0x0592B256, 0x02B317F1,
    0x04E75DA1, 0x02DE6008, 0x01B7DA78, 0x03743CD0, 0x01860C6B, 0x01E739C8, 0x01966C60, 0x00FBFEFB,
    0x034FCCBC, 0x00519B93, 0x02758D6B, 0x04C6755B, 0x0380D9B5, 0x0406C683, 0x03D9FDA6, 0x04897E9E,
    0x02D07AA3, 0x05461B7C, 0x04E9DD54, 0x02EF2ED5, 0x04242D24, 0x0087F8E7, 0x056D3600, 0x025186F5,
    0x0268BD92, 0x056216DE, 0x05D2D348, 0x047411E1, 0x0036DB96, 0x01F2F742, 0x0154EDDC, 0x0438C130,
    0x02FAADC7, 0x03F49D29, 0x04A26908, 0x008A3709, 0x03B36A9F, 0x0535A1EF, 0x038E8255, 0x038DB23D,
    0x004307C6, 0x02DAE91C, 0x02C4597A, 0x038AC797, 0x0405D81B, 0x0236994D, 0x030FBA57, 0x054678D4,
    0x04CBA179, 0x023EBD1A, 0x0431FF07, 0x05DFB116, 0x01C025ED, 0x031A49A7, 0x056A7FF1, 0x03AF06B5,
    0x034CA096, 0x0246102F, 0x05A06214, 0x037D84CB, 0x04287A0B, 0x008B0D29, 0x05D5B02B, 0x012B5330,
    0x037CFF5E, 0x0223B03A, 0x031C4F9D, 0x02CE5AD7, 0x030B92C6, 0x0331051B, 0x03C0698D, 0x0173A11D,
    0x001E6E01, 0x05D28C03, 0x024241D3, 0x006B25BD, 0x038FEAD1, 0x009F4B8C, 0x04503842, 0x00C4DD36,
    0x00B4CCD4, 0x02791E02, 0x04DEC4DC, 0x01449BDC, 0x00B16DC4, 0x00D8172F, 0x003087D2, 0x01F352FA,
    0x01E71E4B, 0x04469C40, 0x057D5C99, 0x0554E7DC, 0x01B51095, 0x001F385C, 0x001E9FD7, 0x012D7B0C,
    0x0286874F, 0x009D33C7, 0x027F8012, 0x04B1276B, 0x039B2067, 0x05199D68, 0x0511CC95, 0x02858EF0,
    0x0417B0A3, 0x03C97C93, 0x0208ABA9, 0x006FD0FA, 0x045061E2, 0x0154E28B, 0x0233CB4B, 0x003317DD,
    0x03835584, 0x02E8FE90, 0x0395ACB5, 0x04E0CD34, 0x03A83465, 0x0339FC00, 0x04E6BD6B, 0x010FDFCA,
    0x03408218, 0x005929F0, 0x0020CBBC, 0x041790DA, 0x0141EF3C, 0x02FAF841, 0x059FD6C8, 0x011B37AF,
    0x034F51FF, 0x00943353, 0x014CF8C7, 0x03AFD8E3, 0x017F0CB1, 0x03B7C786, 0x008C7626, 0x00B6EF75,
    0x04C283C0, 0x0211D2AB, 0x01D1DB09, 0x0460BB08, 0x02AC8060, 0x02B606DC, 0x05D71A74, 0x03271469,
    0x042094CF, 0x0048516B, 0x0156C0DD, 0x02F4D525, 0x0304F3DF, 0x04F5BCDE, 0x03563559, 0x04D68B5E,
    0x01F2B089, 0x02F92EA6, 0x0004CE10, 0x01F58FCD, 0x04CA6DE2, 0x00F86EB7, 0x045024EC, 0x05D005AA,
    0x009A15FF, 0x05D6529C, 0x008524FF, 0x05036381, 0x04AC0184, 0x031969EC, 0x020E8EB9, 0x005493A9,
    0x0044A137, 0x02A7F408, 0x00D7E781, 0x05D9DA7B, 0x05609A9A, 0x032779A8, 0x05AF432D, 0x053ED3BD,
    0x05C54B30, 0x04596361, 0x00F19E39, 0x04C91AF0, 0x053AB4A6, 0x01437A47, 0x009C017E, 0x02A6FE1E,
    0x05D6E7AC, 0x02275860, 0x04AE8110, 0x016F3BAB, 0x051A0358, 0x05EDDDFE, 0x008A8772, 0x004D5937,
    0x04B2CFC8, 0x0061333C, 0x0049B03B, 0x058D2A43, 0x0362B35B, 0x00EB101E, 0x0332A0CB, 0x05AA648F,
    0x01FCCFEC, 0x0126CD7E, 0x01CFDF4D, 0x05D55417, 0x0431D908, 0x02CC0D25, 0x01658E7A, 0x021D76F6,
    0x02CF9237, 0x0055C8F1, 0x0217AE4D, 0x00A15841, 0x046991E8, 0x037BB757, 0x029B8B66, 0x058F68FC,
    0x05E99EA3, 0x008E31DE, 0x044A334A, 0x029A9314, 0x0369FE1D, 0x04DA7C57, 0x019E5494, 0x01148929,
    0x00756F4F, 0x024FD1B5, 0x042D8299, 0x030B2E1C, 0x000EF7F3, 0x04A89623, 0x025628CA, 0x039BCABF,
    0x034AD63C, 0x02598BC9, 0x03EFBC0B, 0x03D56B0D, 0x0567957F, 0x03AFF6F8, 0x01F2FB07, 0x05946A32,
    0x050CE55C, 0x05548228, 0x01181713, 0x033A00BE, 0x00CC6FDB, 0x04FF1B0E, 0x05313D17, 0x040070F7,
    0x029BA36C, 0x037213DF, 0x0328ACA9, 0x0115720F, 0x056E6888, 0x004D9A8C, 0x0514BFFB, 0x036F3826,
    0x055706AD, 0x0301B085, 0x05C08013, 0x053F2674, 0x002308C7, 0x015F2AD3, 0x02FEAB8A, 0x034DEBDA,
    0x020858A9, 0x02EFF041, 0x03A5A359, 0x00A90546, 0x014BA428, 0x00CB58E0, 0x049744FA, 0x03DC403E,
    0x059F8B53, 0x0571359A, 0x00FAC464, 0x053DAAA4, 0x00DA8BC6, 0x052F2711, 0x014746BC, 0x033BF03F,
    0x02B39D5F, 0x04431925, 0x034B30D2, 0x0190737C, 0x01098F18, 0x03A0CEF9, 0x02006EF7, 0x0410FB46,
    0x03A0FA73, 0x05A2009C, 0x00AABAC3, 0x01BD90EA, 0x0063ED97, 0x036DA080, 0x05119523, 0x00B0A7F1,
    0x0129A016, 0x02EE6D88, 0x05547999, 0x0230B218, 0x027FE8AC, 0x05BA1204, 0x03F6CBFE, 0x04B62379,
    0x052EBD27, 0x01AE2653, 0x01234164, 0x05E80D5E, 0x0188B2F3, 0x04F46D42, 0x00D53B86, 0x012A5310,
    0x0419C874, 0x0209F34F, 0x0584DAC2, 0x00562B31, 0x05A66498, 0x01E9C7FB, 0x03118004, 0x0060DA99,
    0x054999D6, 0x0565D465, 0x0179A9B4, 0x051B1463, 0x059A06FE, 0x02F74315, 0x024C8640, 0x0335C762,
    0x05E2D7BC, 0x00FDF391, 0x0402036E, 0x042148D8, 0x012E4909, 0x02BF3F8C, 0x008FF623, 0x044AD0FE,
    0x02374C5B, 0x03C2BA85, 0x0014B251, 0x05AC3921, 0x0039E340, 0x00543D9E, 0x0030891B, 0x04C451EC,
    0x036AF719, 0x0278A32D, 0x04B40231, 0x04E66072, 0x02AB7ED1, 0x00F721F5, 0x0577EB12, 0x04A38D2B,
    0x027575EE, 0x00A8E00C, 0x02419226, 0x05C55212, 0x041B8651, 0x0157A51F, 0x0261AE04, 0x0563F15B,
    0x00477185, 0x007E6D03, 0x0193933F, 0x05E6A1C5, 0x0343D18D, 0x042CBFFD, 0x037DDCC6, 0x03B7D027,
    0x01488A14, 0x0431E829, 0x00449BF3, 0x01F59F15, 0x03872E6E, 0x00778DF2, 0x039F1213, 0x02B86455,
    0x0135E13E, 0x008B899A, 0x008B9410, 0x04513414, 0x053426FB, 0x057953E7, 0x00B6AF3B, 0x0342E839,
    0x018DD096, 0x03F7ADC0, 0x04BC8993, 0x024760DA, 0x011CB9FF, 0x037C577B, 0x04579E6E, 0x01E2D96B,
    0x0005877C, 0x01E09B4A, 0x054A1E93, 0x02E90CF4, 0x001F0C0F, 0x00FDBADA, 0x02425422, 0x01960396,
    0x0010EDB4, 0x007EC131, 0x0439EC55, 0x04060D40, 0x03A8F482, 0x02720876, 0x03933AB8, 0x01D7BE83,
    0x02372EFE, 0x05A0D666, 0x0415F180, 0x00E217CE, 0x014D73BA, 0x04200590, 0x01FA9C35, 0x00F76C50,
    0x015D0214, 0x00A22FAA, 0x05B54C87, 0x01FA35F3, 0x023E34BE, 0x058DD813, 0x00BDF455, 0x01A2F4D4,
    0x0061DA56, 0x05224F81, 0x0522E325, 0x0141DB9D, 0x0575D402, 0x003CADBE, 0x01FB0A20, 0x012D31B1,
    0x04F01669, 0x05AEA4BD, 0x05A880E1, 0x02DC2CD5, 0x00B215AD, 0x0177BA2A, 0x00040E0B, 0x04ABD9F9,
    0x00CDC817, 0x03D88ED1, 0x00FF5250, 0x050810BC, 0x00317605, 0x015819F7, 0x05894E11, 0x03CD5974,
    0x01B80598, 0x049FD0AB, 0x05B02018, 0x055D325F, 0x03AD2D34, 0x045FB915, 0x033AE9B1, 0x03F2F65A,
    0x01FC4F53, 0x02CF3204, 0x004113A3, 0x020BC205, 0x053C6C0D, 0x00ABE179, 0x0176C9B4, 0x00118F43,
    0x05567999, 0x018557A3, 0x037B4E37, 0x01F029DE, 0x03A899ED, 0x035B14D3, 0x045D6D45, 0x026603ED,
    0x04DCB4FD, 0x01DA7648, 0x01472EEE, 0x05F029FE, 0x0489476F, 0x05694441, 0x058487DE, 0x02C0337E,
    0x021B8FF1, 0x004E707D, 0x047B9B6B, 0x002A5C30, 0x038E316B, 0x01258F71, 0x025B73A8, 0x02725978,
    0x03B55B27, 0x04AA180F, 0x02420400, 0x02C78F3E, 0x046C76BC, 0x01DEEE1E, 0x012B0060, 0x053AE7C7,
    0x05F0A081, 0x04C48675, 0x02E470A2, 0x018236EE, 0x02A76C09, 0x04DD7570, 0x02779741, 0x040D1A72,
    0x021AF367, 0x01017D33, 0x02FA6294, 0x035AA386, 0x03163688, 0x05CA5572, 0x058A3A64, 0x00193334,
    0x0222E0FE, 0x01AB10A8, 0x02C5AACC, 0x04E244D6, 0x04532EAE, 0x0231FAC5, 0x04743A8A, 0x02C0C267,
    0x04CA6D26, 0x01821249, 0x0197E78C, 0x025D80EB, 0x000613FC, 0x034AB803, 0x0567F964, 0x0586BA83,
    0x0371D945, 0x033629F2, 0x01537D1A, 0x01AADD98, 0x028753C3, 0x007001D0, 0x01B5EC93, 0x033C2E67,
    0x049A418B, 0x02F3352C, 0x051255A0, 0x058A4AFC, 0x02357FF3, 0x04B793EC, 0x019F604A, 0x01901095,
    0x04C5A445, 0x0161B991, 0x047CEC3E, 0x0237F1EA, 0x040B3FD2, 0x0092283E, 0x03F0E6B6, 0x01CC4D4B,
    0x0304C45C, 0x037209DA, 0x04857A52, 0x01A80B2D, 0x0041B26A, 0x00FDC5DE, 0x013EE9F1, 0x00BE48A0,
    0x0500B832, 0x0407B0AF, 0x035B5B6D, 0x054678F6, 0x01E9A468, 0x051BDBA6, 0x0284E5D3, 0x01CD9022,
    0x03B44BBA, 0x050AF8AC, 0x0483E718, 0x022BE5CA, 0x03BB7886, 0x050B7CF2, 0x0473CCEE, 0x00DFCF55,
    0x046DEA9E, 0x01B13C11, 0x033FBC8D, 0x024B83E0, 0x04F486F9, 0x01B13360, 0x058CD401, 0x012749A0,
    0x00147C34, 0x019FF0CD, 0x00E53ECE, 0x01D1D5EB, 0x04DE993F, 0x0063BB94, 0x031B29AF, 0x01C99231,
    0x044D04F4, 0x008C7E33, 0x01A2F61B, 0x03F0BDAF, 0x04A56ADE, 0x0599E146, 0x02831CEF, 0x0285AE92,
    0x05BFDF1D, 0x019E4AE1, 0x05082B81, 0x01F955E6, 0x04DF316C, 0x000A1719, 0x04FC559D, 0x03C2C195,
    0x01C55BEF, 0x03F454C3, 0x0091C0C7, 0x04DFA477, 0x0153C7F4, 0x03994C51, 0x01638D52, 0x0389F04C,
    0x01B8EDBA, 0x01BE35F0, 0x006C63FA, 0x03EBBAB9, 0x018895ED, 0x009E259F, 0x04BEA36F, 0x03D2238C,
    0x02E4DE61, 0x0137974C, 0x00A71922, 0x0294FDCD, 0x00E9892D, 0x05CE5753, 0x04C22FE5, 0x0212EAF3,
    0x058266D8, 0x035CE7B5, 0x000E0A92, 0x031C4A46, 0x013BF885, 0x058127D2, 0x03304E81, 0x038C3741,
    0x0438B7A3, 0x01B19FB8, 0x0106D8ED, 0x05853899, 0x022E84DC, 0x03420F63, 0x0449C7CB, 0x048D8060,
    0x012C43EF, 0x04EDFAB9, 0x0381B855, 0x031E36C7, 0x013723DB, 0x02BD08FC, 0x02BEBA2E, 0x001372C9,
    0x00B3F149, 0x05F1C5D6, 0x04D34A5A, 0x029C3B38, 0x05D09236, 0x01DFE6B7, 0x04AE89A2, 0x04A9EB7E,
    0x0121E78D, 0x041C7A76, 0x0326B9A8, 0x02304BBC, 0x028AF8CF, 0x01C7F5FB, 0x02AC6261, 0x054D47A9,
    0x013B1044, 0x059CC2DC, 0x052A7C8C, 0x02816070, 0x04A14C57, 0x05BCFF59, 0x0327067E, 0x010F8701,
    0x02F754D4, 0x041872B4, 0x0537EB95, 0x05918453, 0x059886CD, 0x05155E95, 0x003AC009, 0x00E7B94F,
    0x0117C91C, 0x03D99C26, 0x02F06CBB, 0x0302C14A, 0x03B3CD0C, 0x006C70C6, 0x012AEF05, 0x047CBC4D,
    0x0548E514, 0x02C76905, 0x056D2FC4, 0x044CC20F, 0x048CC4BE, 0x012E7D5F, 0x057E8B4C, 0x01C9ADCB,
    0x003AB109, 0x052CA583, 0x05F49A6D, 0x00E6F464, 0x01C35470, 0x01D6D442, 0x046C8BF0, 0x02528FCA,
    0x01184BA6, 0x01FB9ACB, 0x0282FCDB, 0x00471CD4, 0x04911883, 0x027BDCBF, 0x00847655, 0x01D332E9,
    0x0569D592, 0x04136A87, 0x00070C76, 0x04515350, 0x03457CC1, 0x041E9853, 0x01A4B4B4, 0x0183879F,
    0x00BEA260, 0x035FE429, 0x00717B5B, 0x05DB7A69, 0x05B978CF, 0x0436D080, 0x0394F41D, 0x053D7CCB,
    0x0141C200, 0x01BB4460, 0x0545F2AB, 0x04204729, 0x0047310D, 0x03D870CB, 0x026DB58B, 0x02AA53EF,
    0x03F7C871, 0x02983089, 0x01CC1611, 0x02D4ECE7, 0x032FB661, 0x04B961FA, 0x056D2F43, 0x011E2996,
    0x01EB862C, 0x04C28435, 0x057E5696, 0x01ECEB9A, 0x024A1DBC, 0x04F150E8, 0x04A85997, 0x0072DE16,
    0x03AE25FE, 0x057B6C5C, 0x051397BF, 0x02FFEA30, 0x04AD6CF7, 0x0005D2FF, 0x016620B6, 0x0068711B,
    0x0089DFEA, 0x03757CF2, 0x05A08D27, 0x045F86A4, 0x0373D93B, 0x059CBD0F, 0x01BFE2D1, 0x0297E4D3,
    0x005E5B33, 0x054D6C88, 0x00EF1C48, 0x0118C267, 0x0081E9D5, 0x047323BE, 0x004B99E2, 0x037373C9,
    0x038C6AAA, 0x0486A0FE, 0x02FDAAE5, 0x029D9AA0, 0x05B8D117, 0x03242867, 0x04A8396A, 0x00DE411F,
    0x03329873, 0x0026A5CF, 0x00B8AB34, 0x006773C1, 0x0248FCC1, 0x0025CA27, 0x00EE052E, 0x0182560D,
    0x054FE08E, 0x014CE21B, 0x00118236, 0x0180EC7E, 0x04DD1A44, 0x019EECD2, 0x01A3BE97, 0x01E833C0,
    0x0405B0F3, 0x00513BDD, 0x014CD7A2, 0x05426ECC, 0x046B059C, 0x03E957E5, 0x00DF5165, 0x02F6DE8B,
    0x015CC0DB, 0x02567D15, 0x00CBA4C1, 0x03287B3A, 0x00180772, 0x01F66966, 0x00A3F4BB, 0x05E526AD,
    0x05195503, 0x00AC4CC7, 0x01770948, 0x03C075B3, 0x0025D2B7, 0x01C8570B, 0x04D3F23E, 0x00EA4BA0,
    0x018AA1E4, 0x040F33E4, 0x04544D76, 0x018BFC9A, 0x05C4DC45, 0x0383E5EF, 0x024A657E, 0x01EB4F91,
    0x02304470, 0x02FEBD0F, 0x04BFC733, 0x00F97973, 0x0266107F, 0x041442FA, 0x05E62BD4, 0x039CF3DB,
    0x012806E5, 0x01ACC063, 0x01C15FB4, 0x044F0D8F, 0x03ECE740, 0x02DD1F82, 0x04B42074, 0x014FB8C0,
    0x02321497, 0x03AB5FF1, 0x057EDEF7, 0x00BDEB6C, 0x03EFB22E, 0x02D475C8, 0x032B0AE7, 0x0340F90C,
    0x035CD6D9, 0x01CA61CC, 0x044526B4, 0x02F9FF9D, 0x013F95A1, 0x04B0E277, 0x03954FA6, 0x044350EC,
    0x03EBDC59, 0x05887DCE, 0x03A9A2DD, 0x00213AB7, 0x024AC8F7, 0x012C3CE9, 0x04D02D51, 0x023923C3,
    0x0453667A, 0x041AEF95, 0x05C02C66, 0x0210BCA7, 0x05DDF1E3, 0x0036D2ED, 0x0077C4F2, 0x00304CA1,
    0x04EF4D19, 0x00BEAD04, 0x05F0FE9C, 0x05439415, 0x05D38DC3, 0x00E5DF37, 0x0534BA35, 0x01FE3775,
    0x0454C7C6, 0x01D18911, 0x03D4180F, 0x020014E8, 0x058CC4D9, 0x056329CC, 0x0056F88C, 0x0197B564,
    0x049725CB, 0x028832EB, 0x0339075B, 0x039421FC, 0x01C24F54, 0x000B7F64, 0x04CBC09A, 0x0348B348,
    0x01AD3E75, 0x0124176E, 0x03E44F27, 0x037CD0F6, 0x0535C5E1, 0x03B9E52F, 0x036806AD, 0x02A40EB7,
    0x040A9F8B, 0x0308D460, 0x01A954C9, 0x005C49A8, 0x000478E0, 0x028B413D, 0x04210CE6, 0x03B383AA,
    0x006CABE9, 0x02B1D9DC, 0x026C9A55, 0x00555FBA, 0x0334423A, 0x00A8DFAA, 0x03EF47F6, 0x03383390,
    0x0321F149, 0x02633DD3, 0x02C1C3C1, 0x02483714, 0x04E27AAE, 0x00E6E248, 0x0454BF4E, 0x017572F2,
    0x057FD9B1, 0x05D7CC78, 0x0479B0F2, 0x05AC2538, 0x031325B4, 0x01104D4E, 0x018E370D, 0x04425ED3,
    0x05B7E6DB, 0x02244534, 0x004FD696, 0x05790029, 0x00944A0D, 0x049B9081, 0x032F6C61, 0x0005F402,
    0x04139FFD, 0x0150B56B, 0x038B7994, 0x018CDB89, 0x00603A96, 0x03FE95A2, 0x039AC030, 0x00DE5BB7,
    0x05541DD5, 0x05996453, 0x05595A0C, 0x05B5ECD9, 0x04F8D0E8, 0x045C4C73, 0x0488E084, 0x035222D0,
    0x0367649D, 0x02D69BFF, 0x004CEF71, 0x023003EF, 0x017F126D, 0x01DF0D2C, 0x053800F6, 0x00B84F04,
    0x03974CAA, 0x0475831B, 0x01FC919E, 0x02BB058B, 0x018E9078, 0x0531413D, 0x02B49715, 0x03D01CDA,
    0x00905FB3, 0x05794266, 0x056EF63F, 0x05D812A0, 0x03DC19AC, 0x017DAE98, 0x0320D7D5, 0x045A3332,
    0x041B9CBD, 0x00624F67, 0x0429764C, 0x01F64112, 0x02D85436, 0x040639AF, 0x00AA57EF, 0x030AEF81,
    0x03014B43, 0x01ACFF4F, 0x00467EBE, 0x034C9C61, 0x0018BFB0, 0x04F5F2BF, 0x0218BD79, 0x0288024A,
    0x00D3D8F5, 0x0458D973, 0x02D30C93, 0x00A6A1D2, 0x02DC33E1, 0x05953FF2, 0x03CEEDB9, 0x0543639B,
    0x03AF7FA9, 0x01860F77, 0x04E58EBB, 0x02DF0998, 0x0093561C, 0x05942A1F, 0x03378382, 0x04DD4B54,
    0x04EBEDFD, 0x044ED4AA, 0x02ABF600, 0x05062E3F, 0x01093054, 0x0539281A, 0x01EEA0B8, 0x04461207,
    0x02E32856, 0x05B9097C, 0x05B48E48, 0x02595BAE, 0x04F84E64, 0x01DD9C50, 0x019A1106, 0x01751A5D,
    0x05A41D57, 0x04E4580A, 0x05CA3898, 0x04076AF2, 0x051162D4, 0x027B1303, 0x0411BDCE, 0x02E86964,
    0x028BA7D6, 0x04440BBD, 0x05694211, 0x02308552, 0x04490FF6, 0x01F8A7D7, 0x0564AF2B, 0x04D412BB,
    0x0338AE56, 0x05C5FB19, 0x00A0BE30, 0x058F9FED, 0x043EBC5E, 0x01732380, 0x0303AD09, 0x027F2BD2,
    0x044ACDA1, 0x052FBC25, 0x0131BE6C, 0x0098828C, 0x007B84E8, 0x056E5D0D, 0x04F5CADF, 0x05BC0B04,
    0x039316F1, 0x03BF745E, 0x048BD899, 0x02655A29, 0x05494288, 0x0291CBB9, 0x03335F99, 0x0221B7AF,
    0x0152A016, 0x03FE1827, 0x036F3105, 0x04B4980F, 0x03090685, 0x01789C40, 0x03F951DE, 0x00FCC257,
    0x03F992AE, 0x0216C798, 0x01800059, 0x0162B171, 0x0569AF55, 0x00E1269F, 0x01F95BAB, 0x00787CB0,
    0x01F98960, 0x04CB0972, 0x0233C3DA, 0x02B325B0, 0x042A4D74, 0x057D9AF0, 0x009BF455, 0x00D533FA,
    0x00B4CFB0, 0x04B57B11,
};


// -- Initialize built-in game offsets databases

// Black Ops 4 SP
std::array<DBGameInfo, 1> GameBlackOps4::SinglePlayerOffsets =
{{
    { 0x889AD50, 0x0, 0x7520300, 0x0 }
}};

// -- Finished with databases

// -- Begin XModelStream structures

struct GfxStreamVertex
{
    uint8_t Color[4];

    uint16_t UVUPosition;
    uint16_t UVVPosition;

    int32_t VertexNormal;
    int32_t VertexTangent;
};

struct GfxStreamWeight
{
    uint8_t WeightVal1;
    uint8_t WeightVal2;
    uint8_t WeightVal3;
    uint8_t WeightVal4;

    uint16_t WeightID1;
    uint16_t WeightID2;
    uint16_t WeightID3;
    uint16_t WeightID4;
};

struct GfxStreamFace
{
    uint16_t Index1;
    uint16_t Index2;
    uint16_t Index3;
};

// -- End XModelStream structures

// -- Black Ops 4 Pool Data Structure

struct BO4XAssetPoolData
{
    // The beginning of the pool
    uint64_t PoolPtr;

    // The size of the asset header
    uint32_t AssetSize;
    // The maximum pool size
    uint32_t PoolSize;

    // Padding
    uint32_t Padding;

    // The amount of assets in the pool
    uint32_t AssetsLoaded;

    // A pointer to the closest free header
    uint64_t PoolFreeHeadPtr;
};

// Verify that our pool data is exactly 0x20
static_assert(sizeof(BO4XAssetPoolData) == 0x20, "Invalid Pool Data Size (Expected 0x20)");

bool GameBlackOps4::LoadOffsets()
{
    // ----------------------------------------------------
    //    Black Ops 4 pools and sizes, XAssetPoolData is an array of pool info for each asset pool in the game
    //    The index of the assets we use are as follows: xanim (3), xmodel (4), ximage (0x9)
    //    Index * sizeof(BO4XAssetPoolData) = the offset of the asset info in this array of data, we can verify it using the xmodel pool and checking for the model hash (0x04647533e968c910)
    //  Notice: Black Ops 4 doesn't store a freePoolHandle at the beginning, so we just read on.
    //    On Black Ops 4, (0x04647533e968c910) will be the first xmodel
    //    Black Ops 4 stringtable, check entries, results may vary
    //    Reading is: (StringIndex * 16) + StringTablePtr + 16
    // ----------------------------------------------------

    // Attempt to load the game offsets
    if (CoDAssets::GameInstance != nullptr)
    {
        // We need the base address of the BO4 Module for ASLR + Heuristics
        auto BaseAddress = CoDAssets::GameInstance->GetMainModuleAddress();

        // Check built-in offsets via game exe mode (SP)
        for (auto& GameOffsets : SinglePlayerOffsets)
        {
            // Read required offsets (XANIM, XMODEL, XIMAGE, RAWFILE RELATED...)
            auto AnimPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 3));
            auto ModelPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 4));
            auto ImagePoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 0x9));
            auto MaterialPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(BaseAddress + GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 6));

            // Apply game offset info
            CoDAssets::GameOffsetInfos.emplace_back(AnimPoolData.PoolPtr);
            CoDAssets::GameOffsetInfos.emplace_back(ModelPoolData.PoolPtr);
            CoDAssets::GameOffsetInfos.emplace_back(ImagePoolData.PoolPtr);
            CoDAssets::GameOffsetInfos.emplace_back(MaterialPoolData.PoolPtr);

            // Verify via first xmodel asset, right now, we're using a hash
            auto FirstXModelHash = CoDAssets::GameInstance->Read<uint64_t>(CoDAssets::GameOffsetInfos[1]);
            // Check
            if (FirstXModelHash == 0x04647533e968c910)
            {
                // Validate sizes
                if (
                    AnimPoolData.AssetSize == sizeof(BO4XAnim) &&
                    ModelPoolData.AssetSize == sizeof(BO4XModel) &&
                    ImagePoolData.AssetSize == sizeof(BO4GfxImage))
                {
                    // Verify string table, otherwise we are all set
                    CoDAssets::GameOffsetInfos.emplace_back(BaseAddress + GameOffsets.StringTable);
                    // Read and apply sizes
                    CoDAssets::GamePoolSizes.emplace_back(AnimPoolData.PoolSize);
                    CoDAssets::GamePoolSizes.emplace_back(ModelPoolData.PoolSize);
                    CoDAssets::GamePoolSizes.emplace_back(ImagePoolData.PoolSize);
                    CoDAssets::GamePoolSizes.emplace_back(MaterialPoolData.PoolSize);
                    // Return success
                    return true;
                }
            }
            // Reset
            CoDAssets::GameOffsetInfos.clear();
        }

        // Attempt to locate via heuristic searching
        auto DBAssetsScan = CoDAssets::GameInstance->Scan("48 89 5C 24 ?? 57 48 83 EC ?? 0F B6 F9 48 8D 05 ?? ?? ?? ??");
        auto StringTableScan = CoDAssets::GameInstance->Scan("48 8B 53 ?? 48 85 D2 74 ?? 48 8B 03 48 89 02");

        // Check that we had hits
        if (DBAssetsScan > 0 && StringTableScan > 0)
        {
            // Load info and verify
            auto GameOffsets = DBGameInfo(
                // Resolve pool info from LEA
                CoDAssets::GameInstance->Read<uint32_t>(DBAssetsScan + 0x10) + (DBAssetsScan + 0x14),
                // We don't use size offsets
                0,
                // Resolve strings from LEA
                CoDAssets::GameInstance->Read<uint32_t>(StringTableScan + 0x12) + (StringTableScan + 0x16),
                // We don't use package offsets
                0
            );

            // In debug, print the info for easy additions later!
#if _DEBUG
            // Format the output
            printf("Heuristic: { 0x%llX, 0x0, 0x%llX, 0x0 }\n", (GameOffsets.DBAssetPools - BaseAddress), (GameOffsets.StringTable - BaseAddress));
#endif


            // Read required offsets (XANIM, XMODEL, XIMAGE)
            auto AnimPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 3));
            auto ModelPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 4));
            auto ImagePoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 0x9));
            auto MaterialPoolData = CoDAssets::GameInstance->Read<BO4XAssetPoolData>(GameOffsets.DBAssetPools + (sizeof(BO4XAssetPoolData) * 6));

            // Apply game offset info
            CoDAssets::GameOffsetInfos.emplace_back(AnimPoolData.PoolPtr);
            CoDAssets::GameOffsetInfos.emplace_back(ModelPoolData.PoolPtr);
            CoDAssets::GameOffsetInfos.emplace_back(ImagePoolData.PoolPtr);
            CoDAssets::GameOffsetInfos.emplace_back(MaterialPoolData.PoolPtr);

            // Verify via first xmodel asset, right now, we're using a hash
            auto FirstXModelHash = CoDAssets::GameInstance->Read<uint64_t>(CoDAssets::GameOffsetInfos[1]);

            // Check
            if (FirstXModelHash == 0x04647533e968c910)
            {
                // Validate sizes
                if (
                    AnimPoolData.AssetSize  == sizeof(BO4XAnim) && 
                    ModelPoolData.AssetSize == sizeof(BO4XModel) && 
                    ImagePoolData.AssetSize == sizeof(BO4GfxImage))
                {
                    // Verify string table, otherwise we are all set
                    CoDAssets::GameOffsetInfos.emplace_back(GameOffsets.StringTable);

                    // Read and apply sizes
                    CoDAssets::GamePoolSizes.emplace_back(AnimPoolData.PoolSize);
                    CoDAssets::GamePoolSizes.emplace_back(ModelPoolData.PoolSize);
                    CoDAssets::GamePoolSizes.emplace_back(ImagePoolData.PoolSize);
                    CoDAssets::GamePoolSizes.emplace_back(MaterialPoolData.PoolSize);

                    // Return success
                    return true;
                }
            }
        }
    }

    // Failed
    return false;
}

uint64_t BO4CalculateHash(const std::string& Name)
{
    const uint64_t FNVPrime = 0x100000001B3;
    const uint64_t FNVOffset = 0xCBF29CE484222325;

    uint64_t Result = FNVOffset;

    for (uint64_t i = 0; i < Name.size(); i++)
    {
        Result ^= Name[i];
        Result *= FNVPrime;
    }
    return Result & 0xFFFFFFFFFFFFFFF;
}

bool GameBlackOps4::LoadAssets()
{
    // Prepare to load game assets, into the AssetPool
    bool NeedsAnims = ExportManager::Config.GetBool("LoadAnimations");
    bool NeedsModels = ExportManager::Config.GetBool("LoadModels");
    bool NeedsImages = ExportManager::Config.GetBool("LoadImages");
    bool NeedsRawFiles = ExportManager::Config.GetBool("LoadRawFiles");
    bool NeedsMaterials = ExportManager::Config.GetBool("LoadMaterials");
    bool NeedsExtInfo = ExportManager::Config.GetBool("needsextinfo");

    /*
        This was implemented as a fix for a specific user who requested it, as the search box is capped at 32767 by Windows
        and this is a workaround, if you're interested in using it, any hashes in this filters file will be ignored on load,
        essentially acting as an excluder, consider it a hidden feature with no support as it was made for a specific use
        case. If you cannot get it to work, do not ask me.
    */
    auto Filters = WraithNameIndex();
    Filters.LoadIndex("package_index\\bo4_filters.wni");

    // Check if we need assets
    if (NeedsAnims)
    {
        // Parse the XAnim pool
        CoDXPoolParser<uint64_t, BO4XAnim>((CoDAssets::GameOffsetInfos[0]), CoDAssets::GamePoolSizes[0], [Filters, NeedsExtInfo](BO4XAnim& Asset, uint64_t& AssetOffset)
        {
            // Mask the name as hashes are 60Bit
            Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

            // Check for filters
            if (Filters.NameDatabase.size() > 0)
            {
                // Check for this asset in DB
                if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
                {
                    // Skip this asset
                    return;
                }
            }

            // Validate and load if need be
            auto AnimName = string::Format("xanim_%llx", Asset.NamePtr);

            // Check for an override in the name DB
            if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
            {
                auto& NewName = AssetNameCache.NameDatabase[Asset.NamePtr];

                if (CoDAssets::VerifiedHashes)
                {
                    if (BO4CalculateHash(NewName) == Asset.NamePtr)
                    {
                        AnimName = NewName;
                    }
                }
                else
                {
                    AnimName = NewName;
                }
            }

            // Log it
            CoDAssets::LogXAsset("Anim", AnimName.ToCString());

            // Make and add
            auto LoadedAnim = new CoDAnim_t();
            // Set
            LoadedAnim->AssetName = AnimName;
            LoadedAnim->AssetPointer = AssetOffset;
            LoadedAnim->Framerate = Asset.Framerate;
            LoadedAnim->FrameCount = Asset.NumFrames;
            LoadedAnim->AssetStatus = WraithAssetStatus::Loaded;
            LoadedAnim->BoneCount = Asset.TotalBoneCount;
            LoadedAnim->ShapeCount = (uint32_t) * (uint16_t*)&Asset.Unknown[0];

            // Parse bone names if requested
            if (NeedsExtInfo)
            {
                for (size_t i = 0; i < LoadedAnim->BoneCount; i++)
                {
                    auto BoneIndex = CoDAssets::GameInstance->Read<uint32_t>(Asset.BoneIDsPtr + i * 4);

                    LoadedAnim->BoneNames.emplace_back(CoDAssets::GameStringHandler(BoneIndex));
                }
            }

            // Add
            CoDAssets::GameAssets->LoadedAssets.push_back(LoadedAnim);
        });
    }

    if (NeedsModels)
    {
        // Parse the XModel pool
        CoDXPoolParser<uint64_t, BO4XModel>((CoDAssets::GameOffsetInfos[1]), CoDAssets::GamePoolSizes[1], [Filters, NeedsExtInfo](BO4XModel& Asset, uint64_t& AssetOffset)
        {
            // Mask the name as hashes are 60Bit
            Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

            // Check for filters
            if (Filters.NameDatabase.size() > 0)
            {
                // Check for this asset in DB
                if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
                {
                    // Skip this asset
                    return;
                }
            }

            // Validate and load if need be
            auto ModelName = string::Format("xmodel_%llx", Asset.NamePtr);

            // Check for an override in the name DB
            if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
            {
                auto& NewName = AssetNameCache.NameDatabase[Asset.NamePtr];

                if (CoDAssets::VerifiedHashes)
                {
                    if (BO4CalculateHash(NewName) == Asset.NamePtr)
                    {
                        ModelName = NewName;
                    }
                }
                else
                {
                    ModelName = NewName;
                }
            }

            // Log it
            CoDAssets::LogXAsset("Model", ModelName.ToCString());

            // Make and add
            auto LoadedModel = new CoDModel_t();
            // Set
            LoadedModel->AssetName         = ModelName;
            LoadedModel->AssetPointer      = AssetOffset;
            LoadedModel->BoneCount         = Asset.NumBones;
            LoadedModel->LodCount          = Asset.NumLods;
            LoadedModel->CosmeticBoneCount = Asset.NumCosmeticBones;
            LoadedModel->AssetStatus = WraithAssetStatus::Loaded;

            // Parse bone names if requested
            if (NeedsExtInfo)
            {
                for (size_t i = 0; i < LoadedModel->BoneCount; i++)
                {
                    auto BoneIndex = CoDAssets::GameInstance->Read<uint32_t>(Asset.BoneIDsPtr + i * 4);

                    LoadedModel->BoneNames.emplace_back(CoDAssets::GameStringHandler(BoneIndex));
                }
            }

            // Add
            CoDAssets::GameAssets->LoadedAssets.push_back(LoadedModel);
        });
    }

    if (NeedsImages)
    {
        // Parse the XModel pool
        CoDXPoolParser<uint64_t, BO4GfxImage>((CoDAssets::GameOffsetInfos[2]), CoDAssets::GamePoolSizes[2], [Filters](BO4GfxImage& Asset, uint64_t& AssetOffset)
        {
            // Mask the name as hashes are 60Bit
            Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

            // Check for filters
            if (Filters.NameDatabase.size() > 0)
            {
                // Check for this asset in DB
                if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
                {
                    // Skip this asset
                    return;
                }
            }

            // Validate and load if need be
            auto ImageName = string::Format("ximage_%llx", Asset.NamePtr);

            // Check for an override in the name DB
            if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
            {
                auto& NewName = AssetNameCache.NameDatabase[Asset.NamePtr];

                if (CoDAssets::VerifiedHashes)
                {
                    if (BO4CalculateHash(NewName) == Asset.NamePtr)
                    {
                        ImageName = NewName;
                    }
                }
                else
                {
                    ImageName = NewName;
                }
            }

            // Log it
            CoDAssets::LogXAsset("Image", ImageName.ToCString());

            // Check for loaded images
            // if (Asset.GfxMipsPtr != 0)
            {
                // Make and add
                auto LoadedImage = new CoDImage_t();
                // Set
                LoadedImage->AssetName = ImageName;
                LoadedImage->AssetPointer = AssetOffset;
                LoadedImage->Width = (uint16_t)Asset.LoadedMipWidth;
                LoadedImage->Height = (uint16_t)Asset.LoadedMipHeight;
                LoadedImage->Format = (uint16_t)Asset.ImageFormat;
                LoadedImage->AssetStatus = WraithAssetStatus::Loaded;
                // Add
                CoDAssets::GameAssets->LoadedAssets.push_back(LoadedImage);
            }
        });
    }

    if (NeedsMaterials)
    {
        // Parse the XModel pool
        CoDXPoolParser<uint64_t, BO4XMaterial>((CoDAssets::GameOffsetInfos[3]), CoDAssets::GamePoolSizes[3], [Filters](BO4XMaterial& Asset, uint64_t& AssetOffset)
        {
            // Mask the name as hashes are 60Bit
            Asset.NamePtr &= 0xFFFFFFFFFFFFFFF;

            // Check for filters
            if (Filters.NameDatabase.size() > 0)
            {
                // Check for this asset in DB
                if (Filters.NameDatabase.find(Asset.NamePtr) != Filters.NameDatabase.end())
                {
                    // Skip this asset
                    return;
                }
            }

            // Validate and load if need be
            auto MaterialName = string::Format("xmaterial_%llx", Asset.NamePtr);

            // Check for an override in the name DB
            if (AssetNameCache.NameDatabase.find(Asset.NamePtr) != AssetNameCache.NameDatabase.end())
            {
                auto& NewName = AssetNameCache.NameDatabase[Asset.NamePtr];

                if (CoDAssets::VerifiedHashes)
                {
                    if (BO4CalculateHash(NewName) == Asset.NamePtr)
                    {
                        MaterialName = NewName;
                    }
                }
                else
                {
                    MaterialName = NewName;
                }
            }

            // Log it
            CoDAssets::LogXAsset("Material", MaterialName.ToCString());

            // Make and add
            auto LoadedImage = new CoDMaterial_t();
            // Set
            LoadedImage->AssetName = MaterialName;
            LoadedImage->AssetPointer = AssetOffset;
            LoadedImage->ImageCount = Asset.ImageCount;
            LoadedImage->AssetStatus = WraithAssetStatus::Loaded;
            // Add
            CoDAssets::GameAssets->LoadedAssets.push_back(LoadedImage);
        });
    }

    // Success, error only on specific load
    return true;
}

std::unique_ptr<XAnim_t> GameBlackOps4::ReadXAnim(const CoDAnim_t* Animation)
{
    // Verify that the program is running
    if (CoDAssets::GameInstance->IsRunning())
    {
        // Prepare to read the xanim
        auto Anim = std::make_unique<XAnim_t>();

        // Read the XAnim structure
        auto AnimData = CoDAssets::GameInstance->Read<BO4XAnim>(Animation->AssetPointer);

        // Copy over default properties
        Anim->AnimationName = Animation->AssetName;
        // Frames and Rate
        Anim->FrameCount = AnimData.NumFrames;
        Anim->FrameRate = AnimData.Framerate;

        // Check for viewmodel animations
        if ((_strnicmp(Animation->AssetName.c_str(), "viewmodel_", 10) == 0) || (_strnicmp(Animation->AssetName.c_str(), "vm_", 3) == 0))
        {
            // This is a viewmodel animation
            Anim->ViewModelAnimation = true;
        }
        ////// Check for additive animations
        ////if (AnimData.AssetType == 0x6)
        ////{
        ////    // This is a additive animation
        ////    Anim->AdditiveAnimation = true;
        ////}
        ////// Check for looping
        ////Anim->LoopingAnimation = (AnimData.LoopingFlag > 0);

        // Read the delta data
        auto AnimDeltaData = CoDAssets::GameInstance->Read<BO4XAnimDeltaParts>(AnimData.DeltaPartsPtr);

        // Copy over pointers
        Anim->BoneIDsPtr = AnimData.BoneIDsPtr;
        Anim->DataBytesPtr = AnimData.DataBytePtr;
        Anim->DataShortsPtr = AnimData.DataShortPtr;
        Anim->DataIntsPtr = AnimData.DataIntPtr;
        Anim->RandomDataBytesPtr = AnimData.RandomDataBytePtr;
        Anim->RandomDataShortsPtr = AnimData.RandomDataShortPtr;
        Anim->NotificationsPtr = AnimData.NotificationsPtr;

        // Bone ID index size
        Anim->BoneIndexSize = 4;

        // Copy over counts
        Anim->NoneRotatedBoneCount         = AnimData.NoneRotatedBoneCount;
        Anim->TwoDRotatedBoneCount         = AnimData.TwoDRotatedBoneCount;
        Anim->NormalRotatedBoneCount       = AnimData.NormalRotatedBoneCount;
        Anim->TwoDStaticRotatedBoneCount   = AnimData.TwoDStaticRotatedBoneCount;
        Anim->NormalStaticRotatedBoneCount = AnimData.NormalStaticRotatedBoneCount;
        Anim->NormalTranslatedBoneCount    = AnimData.NormalTranslatedBoneCount;
        Anim->PreciseTranslatedBoneCount   = AnimData.PreciseTranslatedBoneCount;
        Anim->StaticTranslatedBoneCount    = AnimData.StaticTranslatedBoneCount;
        Anim->NoneTranslatedBoneCount      = AnimData.NoneTranslatedBoneCount;
        Anim->TotalBoneCount               = AnimData.TotalBoneCount;
        Anim->NotificationCount            = AnimData.NotificationCount;

        // Copy delta
        Anim->DeltaTranslationPtr   = AnimDeltaData.DeltaTranslationsPtr;
        Anim->Delta2DRotationsPtr   = AnimDeltaData.Delta2DRotationsPtr;
        Anim->Delta3DRotationsPtr   = AnimDeltaData.Delta3DRotationsPtr;
        Anim->BlendShapeNamesPtr    = AnimData.UnknownPtr;
        Anim->BlendShapeWeightsPtr  = AnimData.UnknownZero1;
        Anim->BlendShapeWeightCount = (uint32_t)*(uint16_t*)&AnimData.Unknown[0];

        // Set types, we use quata for BO4
        Anim->RotationType = AnimationKeyTypes::QuatPackingA;
        Anim->TranslationType = AnimationKeyTypes::MinSizeTable;

        // Black Ops 4 doesn't support inline indicies
        Anim->SupportsInlineIndicies = false;

        // Return it
        return Anim;
    }
    // Not running
    return nullptr;
}

std::unique_ptr<XModel_t> GameBlackOps4::ReadXModel(const CoDModel_t* Model)
{
    // Verify that the program is running
    if (CoDAssets::GameInstance->IsRunning())
    {
        // Read the XModel structure
        auto ModelData = CoDAssets::GameInstance->Read<BO4XModel>(Model->AssetPointer);

        // Prepare to read the xmodel (Reserving space for lods)
        auto ModelAsset = std::make_unique<XModel_t>(ModelData.NumLods);

        // Copy over default properties
        ModelAsset->ModelName = Model->AssetName;
        // Bone counts
        ModelAsset->BoneCount = ModelData.NumBones;
        ModelAsset->RootBoneCount = ModelData.NumRootBones;
        ModelAsset->CosmeticBoneCount = ModelData.NumCosmeticBones;

        // Bone data type
        ModelAsset->BoneRotationData = BoneDataTypes::QuatPackingA;

        // We are streamed
        ModelAsset->IsModelStreamed = true;

        // Bone id info
        ModelAsset->BoneIDsPtr = ModelData.BoneIDsPtr;
        ModelAsset->BoneIndexSize = 4;

        // Bone parent info
        ModelAsset->BoneParentsPtr = ModelData.ParentListPtr;
        ModelAsset->BoneParentSize = 1;

        // Local bone pointers
        ModelAsset->RotationsPtr = ModelData.RotationsPtr;
        ModelAsset->TranslationsPtr = ModelData.TranslationsPtr;

        // Global matricies
        ModelAsset->BaseMatriciesPtr = ModelData.BaseMatriciesPtr;

        // Prepare to parse lods
        for (uint32_t i = 0; i < ModelData.NumLods; i++)
        {
            // Read the lod
            auto LODInfo = CoDAssets::GameInstance->Read<BO4XModelLod>(ModelData.ModelLodPtrs[i]);
            // Create the lod and grab reference
            ModelAsset->ModelLods.emplace_back(LODInfo.NumSurfs);
            // Grab reference
            auto& LodReference = ModelAsset->ModelLods[i];

            // Set distance
            LodReference.LodDistance = LODInfo.LodDistance;

            // Set stream key and info ptr
            LodReference.LODStreamKey = LODInfo.LODStreamKey;
            LodReference.LODStreamInfoPtr = LODInfo.XModelMeshPtr;

            // Grab pointer from the lod itself
            auto XSurfacePtr = LODInfo.XSurfacePtr;

            // Skip 8 bytes in materials
            ModelData.MaterialHandlesPtr += 8;
            // Read material handles ptr
            auto MaterialHandlesPtr = CoDAssets::GameInstance->Read<uint64_t>(ModelData.MaterialHandlesPtr);
            // Advance 8 and skip 16 bytes
            ModelData.MaterialHandlesPtr += 0x10;

            // Load surfaces
            for (uint32_t s = 0; s < LODInfo.NumSurfs; s++)
            {
                // Create the surface and grab reference
                LodReference.Submeshes.emplace_back();
                // Grab reference
                auto& SubmeshReference = LodReference.Submeshes[s];

                // Read the surface data
                auto SurfaceInfo = CoDAssets::GameInstance->Read<BO4XModelSurface>(XSurfacePtr);
                // Apply surface info
                SubmeshReference.VertexCount = SurfaceInfo.VertexCount;
                SubmeshReference.FaceCount = SurfaceInfo.FacesCount;
                SubmeshReference.VertexPtr = SurfaceInfo.VerticiesIndex;
                SubmeshReference.FacesPtr = SurfaceInfo.FacesIndex;

                // Assign weight info to the count slots, to save memory
                SubmeshReference.WeightCounts[0] = SurfaceInfo.Flag1;
                SubmeshReference.WeightCounts[1] = SurfaceInfo.Flag2;
                SubmeshReference.WeightCounts[2] = SurfaceInfo.Flag3;
                SubmeshReference.WeightCounts[3] = SurfaceInfo.Flag4;

                // Read this submesh's material handle
                auto MaterialHandle = CoDAssets::GameInstance->Read<uint64_t>(MaterialHandlesPtr);
                // Create the material and add it
                LodReference.Materials.emplace_back(ReadXMaterial(MaterialHandle));

                // Advance
                XSurfacePtr += sizeof(BO4XModelSurface);
                MaterialHandlesPtr += sizeof(uint64_t);
            }
        }

        // Return it
        return ModelAsset;
    }
    // Not running
    return nullptr;
}

std::unique_ptr<XImageDDS> GameBlackOps4::ReadXImage(const CoDImage_t* Image)
{
    // Proxy off
    return LoadXImage(XImage_t(ImageUsageType::DiffuseMap, 0, Image->AssetPointer, Image->AssetName));
}

const XMaterial_t GameBlackOps4::ReadXMaterial(uint64_t MaterialPointer)
{
    // Prepare to parse the material
    auto MaterialData = CoDAssets::GameInstance->Read<BO4XMaterial>(MaterialPointer);

    // Mask the name (some bits are used for other stuffs)
    MaterialData.NamePtr &= 0xFFFFFFFFFFFFFFF;
    // Allocate a new material with the given image count
    XMaterial_t Result(MaterialData.ImageCount);
    // Clean the name, then apply it
    Result.MaterialName = string::Format("xmaterial_%llx", MaterialData.NamePtr);

    // Check for an override in the name DB
    if (AssetNameCache.NameDatabase.find(MaterialData.NamePtr) != AssetNameCache.NameDatabase.end())
        Result.MaterialName = IO::Path::GetFileNamePurgeExtensions(AssetNameCache.NameDatabase[MaterialData.NamePtr].c_str());

    // Iterate over material images, assign proper references if available
    for (uint32_t m = 0; m < MaterialData.ImageCount; m++)
    {
        // Read the image info
        auto ImageInfo = CoDAssets::GameInstance->Read<BO4XMaterialImage>(MaterialData.ImageTablePtr);

        // Get Hash and mask it (some bits are used for other stuffs)
        auto ImageHash = CoDAssets::GameInstance->Read<uint64_t>(ImageInfo.ImagePtr + 0x20) & 0xFFFFFFFFFFFFFFF;

        // Get the image name
        auto ImageName = string::Format("ximage_%llx", ImageHash);

        // Check for an override in the name DB
        if (AssetNameCache.NameDatabase.find(ImageHash) != AssetNameCache.NameDatabase.end())
            ImageName = AssetNameCache.NameDatabase[ImageHash];

        // Default type
        auto DefaultUsage = ImageUsageType::Unknown;
        // Check 
        switch (ImageInfo.SemanticHash)
        {
        case 0xA0AB1041:
            DefaultUsage = ImageUsageType::DiffuseMap;
            break;
        case 0x59D30D0F:
            DefaultUsage = ImageUsageType::NormalMap;
            break;
        case 0xEC443804:
            DefaultUsage = ImageUsageType::SpecularMap;
            break;
        }

        // Assign the new image
        Result.Images.emplace_back(DefaultUsage, ImageInfo.SemanticHash, ImageInfo.ImagePtr, ImageName.ToCString());

        // Advance
        MaterialData.ImageTablePtr += sizeof(BO4XMaterialImage);
    }

    // Return it
    return Result;
}

std::unique_ptr<XImageDDS> GameBlackOps4::LoadXImage(const XImage_t& Image)
{
    // Prepare to load an image, we need to rip loaded and streamed ones
    uint32_t ResultSize = 0;

    // We must read the image data
    auto ImageInfo = CoDAssets::GameInstance->Read<BO4GfxImage>(Image.ImagePtr);

    // Calculate the largest image mip
    uint32_t LargestMip = 0;
    uint32_t LargestWidth = 0;
    uint32_t LargestHeight = 0;
    uint64_t LargestHash = 0;

    // Loop and calculate
    for (uint32_t i = 0; i < ImageInfo.GfxMipMaps; i++)
    {
        // Load Mip Map
        auto MipMap = CoDAssets::GameInstance->Read<BO4GfxMip>(ImageInfo.GfxMipsPtr);
        // Compare widths
        if (MipMap.Width > LargestWidth)
        {
            LargestMip = i;
            LargestWidth = MipMap.Width;
            LargestHeight = MipMap.Height;
            LargestHash = MipMap.HashID;
        }
        // Advance Mip Map Pointer
        ImageInfo.GfxMipsPtr += sizeof(BO4GfxMip);
    }

    // Calculate proper image format (Convert signed to unsigned)
    switch (ImageInfo.ImageFormat)
    {
        // Fix invalid BC1_SRGB images, swap to BC1_UNORM
    case 72: ImageInfo.ImageFormat = 71; break;
        // Fix invalid BC2_SRGB images, swap to BC2_UNORM
    case 75: ImageInfo.ImageFormat = 74; break;
        // Fix invalid BC3_SRGB images, swap to BC3_UNORM
    case 78: ImageInfo.ImageFormat = 77; break;
        // Fix invalid BC7_SRGB images, swap to BC7_UNORM
    case 99: ImageInfo.ImageFormat = 98; break;
    }

    // Buffer
    std::unique_ptr<uint8_t[]> ImageData = nullptr;

    // Check if we're missing a hash / size
    if (LargestWidth == 0 || LargestHash == 0)
    {
        // Set sizes
        LargestWidth = ImageInfo.LoadedMipWidth;
        LargestHeight = ImageInfo.LoadedMipHeight;

        // Temporary size
        uintptr_t ImageMemoryResult = 0;
        // We have a loaded image, prepare to dump from memory
        auto ImageMemoryBuffer = CoDAssets::GameInstance->Read(ImageInfo.LoadedMipPtr, ImageInfo.LoadedMipSize, ImageMemoryResult);

        // Make sure we got it
        if (ImageMemoryBuffer != nullptr)
        {
            // Allocate a safe block
            ImageData = std::make_unique<uint8_t[]>((uint32_t)ImageMemoryResult);
            // Copy data over
            std::memcpy(ImageData.get(), ImageMemoryBuffer, ImageMemoryResult);

            // Set size
            ResultSize = (uint32_t)ImageMemoryResult;

            // Clean up
            delete[] ImageMemoryBuffer;
        }
    }
    else
    {
        // We have a streamed image, prepare to extract
        ImageData = CoDAssets::GamePackageCache->ExtractPackageObject(LargestHash, ResultSize);
    }

    // Prepare if we have it
    if (ImageData != nullptr)
    {
        // Prepare to create a MemoryDDS file
        auto Result = CoDRawImageTranslator::TranslateBC(ImageData, ResultSize, LargestWidth, LargestHeight, ImageInfo.ImageFormat);

        // Check for, and apply patch if required, if we got a raw result
        if (Result != nullptr && Image.ImageUsage == ImageUsageType::NormalMap && ExportManager::Config.GetBool("PatchNormals"))
        {
            // Set normal map patch
            Result->ImagePatchType = ImagePatch::Normal_Expand;
        }

        // Return it
        return Result;
    }

    // Failed to load the image
    return nullptr;
}

#pragma pack(push, 1)
struct BO4XModelMeshInfoEx
{
    uint8_t StatusFlag;
    uint8_t Flag2;
    uint8_t Flag3;
    uint8_t Flag4;

    uint32_t VertexCount;
    uint32_t WeightCount;
    uint32_t FacesCount;

    uint8_t Padding[0x10];

    uint64_t XModelMeshBufferPtr;
    uint32_t XModelMeshBufferSize;

    uint32_t VertexOffset;
    uint32_t UVOffset;
    uint32_t FacesOffset;
    uint32_t WeightsOffset;
    uint32_t BlendShapesOffset;
    uint8_t Pad[416];
    uint32_t BlendShapeCount;
    uint32_t UnknownPossibleValueOrPad;
    uint64_t BlendShapeNames;
    uint64_t BlendShapeIndexes;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct Bo4GfxBlendShapeVert
{
    uint16_t FlagsAndShapeIndex;
    uint16_t X;
    uint16_t Y;
    uint16_t Z;
    uint16_t Unk0; // Possibly Normal/Tangent
    uint16_t Unk1; // Possibly Normal/Tangent
    uint16_t Unk2; // Possibly Normal/Tangent
    uint16_t Unk3; // Possibly Normal/Tangent
};
#pragma pack(pop)

struct Bo4BlendShapeInfo
{
    uint32_t Name;
    uint32_t Index;
};


void GameBlackOps4::LoadXModel(const XModelLod_t& ModelLOD, const std::unique_ptr<WraithModel>& ResultModel)
{
    // Check if we want Vertex Colors
    bool ExportColors = ExportManager::Config.GetBool("exportvtxcolor");
    // Read the mesh information
    auto MeshInfo = CoDAssets::GameInstance->Read<BO4XModelMeshInfoEx>(ModelLOD.LODStreamInfoPtr);

    // A buffer for the mesh data
    std::unique_ptr<uint8_t[]> MeshDataBuffer = nullptr;
    // Resulting size
    uint64_t MeshDataBufferSize = 0;

    // Vertex has extended vertex information
    bool HasExtendedVertexInfo = (MeshInfo.StatusFlag & 64) != 0;

    // Determine if we need to load the mesh or not (Seems flag == 8 is loaded)
    if ((MeshInfo.StatusFlag & 0x3F) == 8)
    {
        // Result size
        uintptr_t ResultSize = 0;
        // The mesh is already loaded, just read it
        auto TemporaryBuffer = CoDAssets::GameInstance->Read(MeshInfo.XModelMeshBufferPtr, MeshInfo.XModelMeshBufferSize, ResultSize);

        // Copy and clean up
        if (TemporaryBuffer != nullptr)
        {
            // Allocate safe
            MeshDataBuffer = std::make_unique<uint8_t[]>(MeshInfo.XModelMeshBufferSize);
            // Copy over
            std::memcpy(MeshDataBuffer.get(), TemporaryBuffer, (size_t)ResultSize);
            // Set size
            MeshDataBufferSize = ResultSize;

            // Clean up
            delete[] TemporaryBuffer;
        }
    }
    else
    {
        // Result size
        uint32_t ResultSize = 0;
        // We must read from the cache
        MeshDataBuffer = CoDAssets::GamePackageCache->ExtractPackageObject(ModelLOD.LODStreamKey, ResultSize);
        // Set size
        MeshDataBufferSize = ResultSize;
    }

    // Continue on success
    if (MeshDataBuffer != nullptr)
    {
        // Make a reader to begin reading the mesh (Don't close)
        auto MeshReader = IO::MemoryReader((int8_t*)MeshDataBuffer.get(), MeshDataBufferSize, true);

        // The total weighted verticies
        uint32_t TotalReadWeights = 0;
        // The maximum weight index
        uint32_t MaximumWeightIndex = ResultModel->BoneCount() - 1;

        // Prepare it for submeshes
        ResultModel->PrepareSubmeshes((uint32_t)ModelLOD.Submeshes.size());

        // Start by reading blendshape info
        auto Vertices = std::make_unique<std::vector<std::pair<uint32_t, Vector3>>[]>(MeshInfo.VertexCount);

        // Check if we have blendshapes
        if (MeshInfo.BlendShapeCount != 0 && MeshInfo.BlendShapeCount <= 256)
        {
            // Index map
            uint32_t Indexes[256];
            // Read names
            for (uint32_t i = 0; i < MeshInfo.BlendShapeCount; i++)
            {
                auto TargetInfo = CoDAssets::GameInstance->Read<Bo4BlendShapeInfo>(MeshInfo.BlendShapeIndexes + i * sizeof(Bo4BlendShapeInfo));
                ResultModel->BlendShapes.push_back(CoDAssets::GameStringHandler(TargetInfo.Name));
                Indexes[TargetInfo.Index] = i;
            }

            // Jump to Blendshapes
            MeshReader.SetPosition(MeshInfo.BlendShapesOffset);
            // Read count
            auto TargetCount = MeshReader.Read<uint32_t>();
            // Create offset buffer
            auto Offsets = std::make_unique<uint32_t[]>(TargetCount);
            MeshReader.Read(TargetCount * sizeof(uint32_t), (int8_t*)Offsets.get());

            // Load each target
            for (uint32_t i = 0; i < TargetCount; i++)
            {
                // Jump to this target
                MeshReader.SetPosition((uint64_t)MeshInfo.BlendShapesOffset + Offsets[i]);
                // Read Info
                auto VertexIndex = MeshReader.Read<uint32_t>();
                auto ShapeCount = MeshReader.Read<uint32_t>();

                // Load each shape for this vertex
                for (uint32_t j = 0; j < ShapeCount; j++)
                {
                    // Load and unpack index and deltas
                    auto ShapeValue = MeshReader.Read<Bo4GfxBlendShapeVert>();
                    auto ShapeIndex = ShapeValue.FlagsAndShapeIndex >> 8;

                    Vertices[VertexIndex].push_back(std::make_pair(
                        (uint32_t)Indexes[ShapeIndex],
                        Vector3(
                            Math::Half::ToFloat(ShapeValue.Unk0),
                            Math::Half::ToFloat(ShapeValue.Unk1),
                            Math::Half::ToFloat(ShapeValue.Unk2)
                        )));
                }
            }
        }

        // Iterate over submeshes
        for (auto& Submesh : ModelLOD.Submeshes)
        {
            // Create and grab a new submesh
            auto& Mesh = ResultModel->AddSubmesh();

            // Set the material (COD has 1 per submesh)
            Mesh.AddMaterial(Submesh.MaterialIndex);

            // Prepare the mesh for the data
            Mesh.PrepareMesh(Submesh.VertexCount, Submesh.FaceCount);

            // Jump to vertex position data, advance to this submeshes verticies
            MeshReader.SetPosition(MeshInfo.VertexOffset + (Submesh.VertexPtr * 12));

            // Iterate over verticies
            for (uint32_t i = 0; i < Submesh.VertexCount; i++)
            {
                // Make a new vertex
                auto& Vertex = Mesh.AddVertex();

                // Read and assign position
                Vertex.Position = MeshReader.Read<Vector3>();
            }

            // Jump to vertex info data, advance to this submeshes info, seek further for extended vertex info
            MeshReader.SetPosition(MeshInfo.UVOffset + (Submesh.VertexPtr * (HasExtendedVertexInfo ? 24 : 16)));

            // Iterate over verticies
            for (uint32_t i = 0; i < Submesh.VertexCount; i++)
            {
                // Grab the reference
                auto& Vertex = Mesh.Verticies[i];

                // Set Shapes
                Vertex.BlendShapeDeltas = Vertices[Submesh.VertexPtr + i];

                // Read vertex data
                auto VertexData = MeshReader.Read<GfxStreamVertex>();

                // Add UV layer
                Vertex.AddUVLayer(Math::Half::ToFloat(VertexData.UVUPosition), Math::Half::ToFloat(VertexData.UVVPosition));

                // Unpack normal
                int32_t PackedX = (((VertexData.VertexNormal >> 0) & ((1 << 10) - 1)) - 512);
                int32_t PackedY = (((VertexData.VertexNormal >> 10) & ((1 << 10) - 1)) - 512);
                int32_t PackedZ = (((VertexData.VertexNormal >> 20) & ((1 << 10) - 1)) - 512);
                // Calculate
                Vertex.Normal.X = ((float)PackedX / 511.0f);
                Vertex.Normal.Y = ((float)PackedY / 511.0f);
                Vertex.Normal.Z = ((float)PackedZ / 511.0f);

                // Add Colors if we want them
                if (ExportColors)
                {
                    Vertex.Color[0] = VertexData.Color[0];
                    Vertex.Color[1] = VertexData.Color[1];
                    Vertex.Color[2] = VertexData.Color[2];
                    Vertex.Color[3] = VertexData.Color[3];
                }
                else
                {
                    Vertex.Color[0] = 0xFF;
                    Vertex.Color[1] = 0xFF;
                    Vertex.Color[2] = 0xFF;
                    Vertex.Color[3] = 0xFF;
                }

                // Skip extended vertex information (first 4 bytes seems to be UV, possibly for better camo UV Mapping)
                if (HasExtendedVertexInfo)
                    MeshReader.Advance(8);
            }

            // Jump to vertex weight data, advance to this submeshes info
            MeshReader.SetPosition(MeshInfo.WeightsOffset + (Submesh.VertexPtr * 12));

            // Iterate over verticies
            for (uint32_t i = 0; i < Submesh.VertexCount; i++)
            {
                // Grab the reference
                auto& Vertex = Mesh.Verticies[i];
                
                // Check if we're a complex weight, up to four weights
                if (((uint8_t)Submesh.WeightCounts[0] & 2) > 0)
                {
                    // Read weight data
                    auto VertexWeight = MeshReader.Read<GfxStreamWeight>();

                    // Add if need be
                    Vertex.AddVertexWeight(VertexWeight.WeightID1, (VertexWeight.WeightVal1 / 255.0f));
                    // Calculate max
                    MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID1, MaximumWeightIndex);

                    // Check for value 2
                    if (VertexWeight.WeightVal2 > 0)
                    {
                        Vertex.AddVertexWeight(VertexWeight.WeightID2, (VertexWeight.WeightVal2 / 255.0f));
                        // Calculate max
                        MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID2, MaximumWeightIndex);
                    }

                    // Check for value 3
                    if (VertexWeight.WeightVal3 > 0)
                    {
                        Vertex.AddVertexWeight(VertexWeight.WeightID3, (VertexWeight.WeightVal3 / 255.0f));
                        // Calculate max
                        MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID3, MaximumWeightIndex);
                    }

                    // Check for value 4
                    if (VertexWeight.WeightVal4 > 0)
                    {
                        Vertex.AddVertexWeight(VertexWeight.WeightID4, (VertexWeight.WeightVal4 / 255.0f));
                        // Calculate max
                        MaximumWeightIndex = std::max<uint32_t>(VertexWeight.WeightID4, MaximumWeightIndex);
                    }

                    // Increase
                    TotalReadWeights++;
                }
                else
                {
                    // Simple weight
                    Vertex.AddVertexWeight(0, 1.0);
                }

            }

            // Jump to face data, advance to this submeshes faces
            MeshReader.SetPosition(MeshInfo.FacesOffset + (Submesh.FacesPtr * 2));

            // Iterate over faces
            for (uint32_t i = 0; i < Submesh.FaceCount; i++)
            {
                // Read data
                auto Face = MeshReader.Read<GfxStreamFace>();

                // Add the face
                Mesh.AddFace(Face.Index1, Face.Index2, Face.Index3);
            }
        }

        // Prepare to generate stream bones if we had a conflict
        if (MaximumWeightIndex > (ResultModel->BoneCount() - 1))
        {
            // Generate stream bones
            auto CurrentBoneCount = ResultModel->BoneCount();
            auto WantedBoneCount = (MaximumWeightIndex + 1);

            // Loop and create
            for (uint32_t i = 0; i < (WantedBoneCount - CurrentBoneCount); i++)
            {
                auto& StreamBone = ResultModel->AddBone();

                // Set name and parent
                StreamBone.TagName = string::Format("smod_bone%d", i);
                StreamBone.BoneParent = 0;
            }

            // Ensure root is tag_origin
            ResultModel->Bones[0].TagName = "tag_origin";
        }
    }
}

std::string GameBlackOps4::DecryptString(uint8_t* InputBuffer, uint8_t InputLength, uint8_t EncryptionID, uint64_t StringHash)
{
    switch ((uint8_t)(EncryptionID + 128))
    {
    case 0:
    {
        // Start values
        uint32_t k = -1741536506;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[(i % 0x11C) + (314 * (k % 5))];
            // Edit key
            j = k + 6;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;

    }
    case 1:
    {
        // Start values
        uint32_t k = 1192577426;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[(314 * (i & 1)) + (k % 0x1F)];
            // Edit key
            j = k - 110;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 3:
    {
        // Start values
        uint32_t k = 877228565;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k -= DecryptionTable[(k % 0x8B) + (314 * (i % 0xAu))];
            // Edit key
            j = k ^ 21;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 7:
    {
        // Start values
        uint32_t k = 1214813561;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k ^= DecryptionTable[k % 0xA1 + 314 * (i % 5u)];
            // Edit key
            j = k + 121;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 8:
    {
        // Start values
        uint32_t k = 57;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k += i;
            // Edit key
            j = k * 57;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 10:
    {
        // Start values
        uint32_t k = -1853736935;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k ^= i;
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k + 25;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 11:
    {
        // Start values
        uint32_t k = 841107494;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k -= DecryptionTable[314 * (i & 3) + k % 0x5D];
            // Edit key
            j = 38 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 14:
    {
        // Start values
        uint32_t k = 2252494689;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[(i & 7) + 314 * (k & 7)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = k + 97;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 17:
    {
        // Start values
        uint32_t k = -2124904183;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x9D + 314 * (k % 3)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = 9 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 18:
    {
        // Start values
        uint32_t k = 2020090434;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k ^= i;
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k + 66;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 20:
    {
        // Start values
        uint32_t k = 628241558;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[i % 0x74 + 314 * (k % 6)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k - 106;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 22:
    {
        // Start values
        uint32_t k = 889284759;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x67 + 314 * (k % 6)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = -105 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 23:
    {
        // Start values
        uint32_t k = 960823304;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k *= i;
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = k + 8;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 24:
    {
        // Start values
        uint32_t k = 609355846;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x11B + 314 * (k % 3)];
            // Edit key
            j = 70 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 25:
    {
        // Start values
        uint32_t k = 1646539289;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k -= DecryptionTable[i % 0x74 + 314 * (k % 0xC)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k + 25;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 26:
    {
        // Start values
        uint32_t k = 592783125;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x19 + 314 * (k % 0xA)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = 21 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 27:
    {
        // Start values
        uint32_t k = 2003114280;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k ^= i;
            // Edit key
            j = k ^ 40;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 29:
    {
        // Start values
        uint32_t k = 295057172;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x114 + 314 * (k % 5)];
            // Edit key
            j = 20 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 30:
    {
        // Start values
        uint32_t k = 2039837206;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k ^= DecryptionTable[k % 0x118 + 314 * (i % 6)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k ^ 0x16;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 34:
    {
        // Start values
        uint32_t k = 39;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k -= i;
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = 39 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 35:
    {
        // Start values
        uint32_t k = 1126761733;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[i % 0xC1 + 314 * (k % 0xC)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = 5 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 36:
    {
        // Start values
        uint32_t k = 680949523;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x34 + 314 * (k % 0xC)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k + 19;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 39:
    {
        // Start values
        uint32_t k = 830817865;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[k % 0xCE + 314 * (i % 6)];
            // Edit key
            j = k ^ 73;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 40:
    {
        // Start values
        uint32_t k = 2187474786;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k ^= DecryptionTable[(k & 0x1F) + 314 * (i % 0xB)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = k ^ 98;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 41:
    {
        // Start values
        uint32_t k = 912361108;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[(i & 1) + 314 * (k % 3)];
            // Edit key
            j = -108 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 43:
    {
        // Start values
        uint32_t k = 1614283080;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k ^= DecryptionTable[i % 0x5F + 314 * (k % 6)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = 72 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 44:
    {
        // Start values
        uint32_t k = 310931476;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[k % 0xB8 + 314 * (i % 7)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = 20 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 46:
    {
        // Start values
        uint32_t k = 1752254548;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[k % 0xF0 + 314 * (i % 7)];
            // Edit key
            j = 84 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 47:
    {
        // Start values
        uint32_t k = -1855434364;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k ^= i;
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = -124 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 49:
    {
        // Start values
        uint32_t k = 339174210;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[k % 0x10C];
            // Edit key
            j = k + 66;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 50:
    {
        // Start values
        uint32_t k = 924357779;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[i % 0x10B + 314 * (k % 0xB)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = k - 109;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 51:
    {
        // Start values
        uint32_t k = -2122213293;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[i % 0x25 + 314 * (k % 0xC)];
            // Edit key
            j = k ^ 0x53;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 52:
    {
        // Start values
        uint32_t k = 2199357493;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k ^= DecryptionTable[(i & 0x1F) + 314 * (k % 6)];
            // Edit key
            j = 53 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 53:
    {
        // Start values
        uint32_t k = 928594017;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k += i;
            // Edit key
            j = k ^ 0x61;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 54:
    {
        // Start values
        uint32_t k = 428896339;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0x41 + 314 * (k % 9)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = k + 83;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 55:
    {
        // Start values
        uint32_t k = 57;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k += i;
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = 57 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 56:
    {
        // Start values
        uint32_t k = 113;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k += i;
            // Edit key
            j = 113 - k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 57:
    {
        // Start values
        uint32_t k = 32;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k *= i;
            // Edit key
            j = k + 32;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 58:
    {
        // Start values
        uint32_t k = 88110114;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k -= DecryptionTable[i % 0x10F + 314 * (k % 6)];
            // Rotate it
            InputBuffer[i] = RotateLeft8(InputBuffer[i], k);
            // Edit key
            j = k ^ 0x22;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 59:
    {
        // Start values
        uint32_t k = 908137505;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[i % 0x32 + 314 * (k % 0xA)];
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = 33 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 60:
    {
        // Start values
        uint32_t k = 1115976849;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k += DecryptionTable[314 * (i & 3) + k % 0x45];
            // Edit key
            j = k ^ 0x91;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 61:
    {
        // Start values
        uint32_t k = 2004443495;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Read from the internal int32 array
            k *= DecryptionTable[i % 0xDC + 314 * (k % 0xB)];
            // Edit key
            j = 103 * k;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    case 63:
    {
        // Start values
        uint32_t k = -105;
        uint8_t j = 0;
        // Loop through bytes
        for (uint8_t i = 0; i < InputLength - 1; i++)
        {
            // Edit values
            k += i;
            // Rotate it
            InputBuffer[i] = RotateRight8(InputBuffer[i], k);
            // Edit key
            j = k ^ 151;
            // Decrypt it if the key and input differ
            InputBuffer[i] = InputBuffer[i] != j ? InputBuffer[i] ^ j : InputBuffer[i];
        }
        // Done
        break;
    }
    default:
        break;
    }
#if _DEBUG
    // Validate strings in debug to check for encryption changes
    uint64_t Hash = 0xCBF29CE484222325;
    // Loop through string
    for (uint8_t i = 0; i < InputLength; i++)
        Hash = 0x100000001B3 * (InputBuffer[i] ^ Hash);
    // Check it against input
    if (Hash != StringHash)
        printf("Hash check failed: ID %i - Input Hash 0x%llX - Hash Result 0x%llX - %s - Size %i\n", (uint8_t)(EncryptionID + 128), StringHash, Hash, InputBuffer, InputLength);
#endif
    // Done
    return std::string(reinterpret_cast<char const*>(InputBuffer), InputLength - 1);
}

std::string GameBlackOps4::LoadStringEntry(uint64_t Index)
{
    // Calculate Offset to String (Offsets[3] = StringTable)
    auto Offset = CoDAssets::GameOffsetInfos[4] + (Index * 20);
    // Read Result
    uint64_t BytesRead = 0;
    // Read Info
    auto StringHash      = CoDAssets::GameInstance->Read<uint64_t>(Offset + 8);
    auto EncryptionID    = CoDAssets::GameInstance->Read<uint8_t>(Offset + 16);
    auto StringSize      = CoDAssets::GameInstance->Read<uint8_t>(Offset + 17);
    // Check 0 length
    if (StringSize == 0)
        return "";
    auto EncryptedString = (uint8_t*)CoDAssets::GameInstance->Read(Offset + 18, StringSize, BytesRead);
    // Pass to decryptor
    auto Result = DecryptString(EncryptedString, StringSize, EncryptionID, StringHash);
    // Clean up
    delete[] EncryptedString;
    // Done
    return Result;
}
void GameBlackOps4::PerformInitialSetup()
{
    // Load Caches
    AssetNameCache.LoadIndex(IO::Path::Combine(System::Environment::GetApplicationPath(), "package_index\\fnv1a_xanims.wni").ToCString());
    AssetNameCache.LoadIndex(IO::Path::Combine(System::Environment::GetApplicationPath(), "package_index\\fnv1a_ximages.wni").ToCString());
    AssetNameCache.LoadIndex(IO::Path::Combine(System::Environment::GetApplicationPath(), "package_index\\fnv1a_xmaterials.wni").ToCString());
    AssetNameCache.LoadIndex(IO::Path::Combine(System::Environment::GetApplicationPath(), "package_index\\fnv1a_xmodels.wni").ToCString());
    AssetNameCache.LoadIndex(IO::Path::Combine(System::Environment::GetApplicationPath(), "package_index\\fnv1a_xsounds.wni").ToCString());

    // Prepare to copy the oodle dll
    auto OurPath = IO::Path::Combine(System::Environment::GetApplicationPath(), "oo2core_6_win64.dll");

    // Copy if not exists
    if (!IO::File::Exists(OurPath))
        IO::File::Copy(IO::Path::Combine(IO::Path::GetDirectoryName(CoDAssets::GameInstance->GetProcessPath().c_str()), "oo2core_6_win64.dll"), OurPath);
}
