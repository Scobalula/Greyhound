#include "stdafx.h"

// The class we are implementing
#include "XMEExport.h"

// We need the textwriter, hashing, and filesystems classes
#include "TextWriter.h"
#include "File.h"
#include "Matrix.h"
#include <unordered_set>

void CodXME::ExportXME(const WraithModel& Model, const std::string& FileName)
{
    // Create a new writer
    auto Writer = IO::StreamWriter(IO::File::Create(FileName.c_str()));
    // Open the model file
    // Write header
    Writer.WriteLine(
        "// Generated by Wraith - Game extraction tools\n"
        "// Please credit DTZxPorter for using it!\n"
        "MODEL\nVERSION 6\n"
    );
    // Write bone count
    Writer.WriteLineFmt("NUMBONES %d", Model.BoneCount());
    // The bone index
    uint32_t BoneIndex = 0;
    // Iterate over the bones
    for (auto& Bone : Model.Bones)
    {
        // The bone id
        Writer.WriteLineFmt("BONE %d %d \"%s\"", BoneIndex, Bone.BoneParent, Bone.TagName.c_str());
        // Advance
        BoneIndex++;
    }
    // New line
    Writer.WriteLine();
    // Reset
    BoneIndex = 0;
    // Loop through bones again for positions
    for (auto& Bone : Model.Bones)
    {
        // Grab rotation matrix
        Math::Matrix RotationMatrix = Math::Matrix::CreateFromQuaternion(Bone.GlobalRotation);
        // Output all bone information
        Writer.WriteLineFmt(
            // The formatted lines to print
            "BONE %d\n"
            "OFFSET %f, %f, %f\n"
            "SCALE %f, %f, %f\n"
            "X %f, %f, %f\n"
            "Y %f, %f, %f\n"
            "Z %f, %f, %f\n",
            // The data for the formatted lines
            BoneIndex,
            Bone.GlobalPosition.X, Bone.GlobalPosition.Y, Bone.GlobalPosition.Z,
            Bone.BoneScale.X, Bone.BoneScale.Y, Bone.BoneScale.Z,
            Math::MathHelper::Clamp(RotationMatrix.Mat(0, 0), -1.0f, 1.0f), Math::MathHelper::Clamp(RotationMatrix.Mat(0, 1), -1.0f, 1.0f), Math::MathHelper::Clamp(RotationMatrix.Mat(0, 2), -1.0f, 1.0f),
            Math::MathHelper::Clamp(RotationMatrix.Mat(1, 0), -1.0f, 1.0f), Math::MathHelper::Clamp(RotationMatrix.Mat(1, 1), -1.0f, 1.0f), Math::MathHelper::Clamp(RotationMatrix.Mat(1, 2), -1.0f, 1.0f),
            Math::MathHelper::Clamp(RotationMatrix.Mat(2, 0), -1.0f, 1.0f), Math::MathHelper::Clamp(RotationMatrix.Mat(2, 1), -1.0f, 1.0f), Math::MathHelper::Clamp(RotationMatrix.Mat(2, 2), -1.0f, 1.0f)
        );
        // Advance
        BoneIndex++;
    }
    // Cache vertex count
    auto VertexCount = Model.VertexCount();
    // Cache face count
    auto FaceCount = Model.FaceCount();
    // Output vert count
    if (VertexCount > UINT16_MAX)
    {
        // Use integer 32
        Writer.WriteLineFmt("NUMVERTS32 %d", VertexCount);
    }
    else
    {
        // Use integer 16
        Writer.WriteLineFmt("NUMVERTS %d", VertexCount);
    }
    // A unique list of material indicies
    std::unordered_set<int32_t> MaterialIndicies;
    // The vertex offset
    uint32_t VertexIndex = 0;
    // Iterate over submeshes
    for (auto& Submesh : Model.Submeshes)
    {
        // Add the material indicies for use later
        MaterialIndicies.insert(Submesh.MaterialIndicies[0]);
        // Iterate over verts and do positions and weights
        for (auto& Vertex : Submesh.Verticies)
        {
            // Write vertex and offset
            if (VertexCount > UINT16_MAX)
            {
                // Use integer 32
                Writer.WriteLineFmt(
                    "VERT32 %d\n"
                    "OFFSET %f, %f, %f",
                    VertexIndex,
                    Vertex.Position.X, Vertex.Position.Y, Vertex.Position.Z
                );
            }
            else
            {
                // Use integer  16
                Writer.WriteLineFmt(
                    "VERT %d\n"
                    "OFFSET %f, %f, %f",
                    VertexIndex,
                    Vertex.Position.X, Vertex.Position.Y, Vertex.Position.Z
                );
            }
            // Handle bone weights
            if (Vertex.WeightCount() == 1)
            {
                // Only weight one bone
                Writer.WriteLineFmt(
                    "BONES 1\n"
                    "BONE %d 1.000000\n",
                    Vertex.Weights[0].BoneIndex
                );
            }
            else
            {
                // Loop and weight all weights
                Writer.WriteLineFmt("BONES %d", (uint32_t)Vertex.WeightCount());
                // Loop
                for (auto& Weight : Vertex.Weights)
                {
                    // Output
                    Writer.WriteLineFmt("BONE %d %f", Weight.BoneIndex, Weight.Weight);
                }
                // New line
                Writer.WriteLine();
            }
            // Increase
            VertexIndex++;
        }
    }
    // Write the number of faces
    Writer.WriteLineFmt("NUMFACES %d", FaceCount);
    // the submesh index
    uint32_t SubmeshIndex = 0;
    // Reset
    VertexIndex = 0;
    // Loop through submeshes
    for (auto& Submesh : Model.Submeshes)
    {
        // Find the index of this submesh's material
        auto FindResult = MaterialIndicies.find(Submesh.MaterialIndicies[0]);
        // Check
        uint32_t IndexOfMaterial = (FindResult != MaterialIndicies.end()) ? (uint32_t)std::distance(MaterialIndicies.begin(), FindResult) : 0;
        // Loop through faces
        for (auto& Face : Submesh.Faces)
        {
            // Output the face information
            Writer.WriteLineFmt("TRI %d %d 0 0", SubmeshIndex, IndexOfMaterial);
            // Output vertex information for the faces (swap for size of verts)
            Writer.WriteLineFmt((VertexCount > UINT16_MAX) ? "VERT32 %d" : "VERT %d", (Face.Index3 + VertexIndex));
            // Output vert information
            Writer.WriteLineFmt(
                "NORMAL %f %f %f\n"
                "COLOR %f %f %f %f\n"
                "UV 1 %f %f",
                Submesh.Verticies[Face.Index3].Normal.X, Submesh.Verticies[Face.Index3].Normal.Y, Submesh.Verticies[Face.Index3].Normal.Z,
                Submesh.Verticies[Face.Index3].Color[0] / 255.0f, Submesh.Verticies[Face.Index3].Color[1] / 255.0f, Submesh.Verticies[Face.Index3].Color[2] / 255.0f, Submesh.Verticies[Face.Index3].Color[3] / 255.0f,
                Submesh.Verticies[Face.Index3].UVLayers[0].U, Submesh.Verticies[Face.Index3].UVLayers[0].V
            );

            // Output vertex information for the faces (swap for size of verts)
            Writer.WriteLineFmt((VertexCount > UINT16_MAX) ? "VERT32 %d" : "VERT %d", (Face.Index1 + VertexIndex));
            // Output vert information
            Writer.WriteLineFmt(
                "NORMAL %f %f %f\n"
                "COLOR %f %f %f %f\n"
                "UV 1 %f %f",
                Submesh.Verticies[Face.Index1].Normal.X, Submesh.Verticies[Face.Index1].Normal.Y, Submesh.Verticies[Face.Index1].Normal.Z,
                Submesh.Verticies[Face.Index1].Color[0] / 255.0f, Submesh.Verticies[Face.Index1].Color[1] / 255.0f, Submesh.Verticies[Face.Index1].Color[2] / 255.0f, Submesh.Verticies[Face.Index1].Color[3] / 255.0f,
                Submesh.Verticies[Face.Index1].UVLayers[0].U, Submesh.Verticies[Face.Index1].UVLayers[0].V
            );

            // Output vertex information for the faces (swap for size of verts)
            Writer.WriteLineFmt((VertexCount > UINT16_MAX) ? "VERT32 %d" : "VERT %d", (Face.Index2 + VertexIndex));
            // Output vert information
            Writer.WriteLineFmt(
                "NORMAL %f %f %f\n"
                "COLOR %f %f %f %f\n"
                "UV 1 %f %f",
                Submesh.Verticies[Face.Index2].Normal.X, Submesh.Verticies[Face.Index2].Normal.Y, Submesh.Verticies[Face.Index2].Normal.Z,
                Submesh.Verticies[Face.Index2].Color[0] / 255.0f, Submesh.Verticies[Face.Index2].Color[1] / 255.0f, Submesh.Verticies[Face.Index2].Color[2] / 255.0f, Submesh.Verticies[Face.Index2].Color[3] / 255.0f,
                Submesh.Verticies[Face.Index2].UVLayers[0].U, Submesh.Verticies[Face.Index2].UVLayers[0].V
            );
        }
        // Increase
        VertexIndex += Submesh.VertexCount();
        // Advance
        SubmeshIndex++;
    }
    // Separator
    Writer.WriteLine();
    // Output submesh count
    Writer.WriteLineFmt("NUMOBJECTS %d", Model.SubmeshCount());
    // Iterate through submeshes
    SubmeshIndex = 0;
    // Loop through
    for (auto& Submesh : Model.Submeshes)
    {
        // Output name
        Writer.WriteLineFmt("OBJECT %d \"WraithMesh_%d\"", SubmeshIndex, SubmeshIndex);
        // Advance
        SubmeshIndex++;
    }
    // Separator
    Writer.WriteLine();
    // Output material count
    Writer.WriteLineFmt("NUMMATERIALS %d", (uint32_t)MaterialIndicies.size());
    // Loop through materials
    uint32_t MaterialIndex = 0;
    // Loop
    for (auto& MaterialOffset : MaterialIndicies)
    {
        // Grab material reference
        const WraithMaterial& Material = (MaterialOffset > -1) ? Model.Materials[MaterialOffset] : WraithMaterial::DefaultMaterial;
        // Output material name
        Writer.WriteFmt("MATERIAL %d \"%s\" \"Phong\" \"", MaterialIndex, Material.MaterialName.c_str());
        // Check for colormap
        // Ensure we don't exceed 128 characters, APE (and probably Linker) limits it...
        if (!string::IsNullOrWhiteSpace(Material.DiffuseMapName.c_str()) && Material.DiffuseMapName.size() < 112)
        {
            // Output color map
            Writer.WriteFmt("color:%s", Material.DiffuseMapName.c_str());
        }
        // Close and output final data
        Writer.WriteLine("\"\nCOLOR 0.000000 0.000000 0.000000 1.000000\nTRANSPARENCY 0.000000 0.000000 0.000000 1.000000\nAMBIENTCOLOR 1.000000 1.000000 1.000000 1.000000\nINCANDESCENCE 0.000000 0.000000 0.000000 1.000000\nCOEFFS 0.800000 0.000000\nGLOW 0.000000 0\nREFRACTIVE 6 1.000000\nSPECULARCOLOR 0.500000 0.500000 0.500000 1.000000\nREFLECTIVECOLOR 0.000000 0.000000 0.000000 1.000000\nREFLECTIVE 1 0.500000\nBLINN -1.000000 -1.000000\nPHONG 20.000000");
        // Advance
        MaterialIndex++;
    }
}